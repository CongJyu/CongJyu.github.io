[{"title":"HNU 夏季学期「程序设计训练 2022」 课程题解（二）","url":"/2022/07/04/2022-07-03-HNU夏季学期程序设计题解二/","content":"\n# HNU 夏季学期「程序设计训练 2022」 课程题解（二）\n\n## 前言\n\n> 「输入两个整数 a 和 b，输出它们的和。」\n>           —— A+B Problem\n\n本题解中的题目描述文字格式全部按照题目原文，描述部分的排版和题解作者无关。\n\n## 代码\n\n代码项目和文件存放于仓库中：\n\n[https://github.com/Chen-Rain/Pitaya](https://github.com/Chen-Rain/Pitaya)\n\n如果无法打开请自行检查网络配置。\n\n## Problem 01. 字符串反转2\n\n### 题目部分\n\n【问题描述】\n\n给定一个句子（只包含字母和空格）， 将句子中的单词位置反转，单词用空格分割, 单词之间只有一个空格，前后没有空格。 比如： “hello xiao mi”-> “mi xiao hello”\n\n【输入形式】\n\n输入数据有多组，每组占一行，包含一个句子(句子长度小于1000个字符)\n\n【输出形式】\n\n对于每个测试示例，要求输出句子中单词反转后形成的句子\n\n【样例输入】\n\n```\nhello xiao mi\nI am a student\n```\n\n【样例输出】\n\n```\nmi xiao hello\nstudent a am I\n```\n\n### 题解部分\n\n【思路】\n\n这道题可以使用常规的字符串反转的思路，也可以用一些奇奇怪怪的方法。一种方法是使用 `vector` 存储字符串中的每一段（词组）；或者像我一样这道题采用直接先把整个字符串反转 `reverse()` 后再逐个单词反转回来的方法。\n\n【Accepted 代码】\n\n[最大规模数据集随机生成程序：测试用](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P01-testing)\n\nC++ 17\n\n```cpp\n// t02p01\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string s;\n    while (getline(cin, s)) {\n        reverse(s.begin(), s.end());\n        int l = 0, r = 0;\n        while (r < (int)s.length()) {\n            while (r < (int)s.length() && s[r] != ' ') {\n                ++r;\n            }\n            reverse(s.begin() + l, s.begin() + r);\n            l = (++r);\n        }\n        cout << s << endl;\n    }\n    return 0;\n}\n```\n\n【可能遇到的问题】\n\n注意输出时的空格控制，防止出现格式错误。\n\n## Problem 02. xxx定律\n\n### 题目部分\n\n【问题描述】\n\n对于一个正整数n，如果是偶数，就把n砍掉一半；如果是奇数，把n变成 3*n+ 1后砍掉一半，直到该数变为1为止。\n请计算需要经过几步才能将n变到1，具体可见样例。\n\n【输入形式】\n\n测试包含多个用例，每个用例包含一个整数n,当n为0 时表示输入结束。（1<=n<=10000）\n\n【输出形式】\n\n对于每组测试用例请输出一个数，表示需要经过的步数,每组输出占一行。\n\n【样例输入】\n\n```\n3\n2\n0\n```\n\n【样例输出】\n\n```\n5\n1\n```\n\n### 题解部分\n\n【思路】\n\n这道题应该是一个数学问题，放进「数学」的 Tag 里面（不是）。只用按照题目的步骤操作就行。对每一个数进行操作，遇到 `0` 退出程序就行。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p02\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    while (true) {\n        int n = 0;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        int counter = 0;\n        while (n != 1) {\n            if (n % 2 == 0) {\n                n /= 2;\n                counter++;\n            } else {\n                n = 3 * n + 1;\n                n /= 2;\n                counter++;\n            }\n        }\n        cout << counter << endl;\n    }\n    return 0;\n}\n```\n\n【可能遇到的问题】\n\n注意控制循环开始和结束的条件，不要越界了。\n\n## Problem 03. 数的距离差\n\n### 题目部分\n\n【问题描述】\n\n给定一组正整数，其中最大值和最小值分别为Max和Min, 其中一个数x到Max和Min的距离差定义为：\n\nabs(abs(x-Max)-(x-Min))\n\n其中abs()为求一个数的绝对值\n\n【输入形式】\n\n包括两行，第一行一个数n，表示第二行有n个正整数\n\n【输出形式】\n\n输出一个数x，该数在所有n个数中的距离差最小；如果有两个数的距离差都是最小，输出较小的哪个\n\n【样例输入 1】\n\n```\n5\n3 1 7 5 9\n```\n\n【样例输出 1】\n\n```\n5\n```\n\n【样例输入 2】\n\n```\n3\n1 3 2\n```\n\n【样例输出 2】\n\n```\n2\n```\n\n### 题解部分\n\n【思路】\n\n好像也是一个纯数学问题。按照题目的步骤操作就行。计算一组数的和、平均值、每一个数与平均值的差等等。可以开两个动态数组 `array` 来存储原来的一组数和每一个数对应与平均值的差。当然使用 `vector` 也没有问题，用着顺手就好。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p03\n\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n = 0;\n    cin >> n;\n    int *a = new int[n];\n    int *b = new int[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        b[i] = a[i];\n    }\n    sort(b, b + n);\n    int max_num = b[n - 1];\n    int min_num = b[0];\n    int delta = 99999999;\n    int flag = 0;\n    for (int i = 0; i < n; ++i) {\n        int temp = abs(abs(a[i] - max_num) - abs(a[i] - min_num));\n        if (delta > temp) {\n            delta = temp;\n            flag = a[i];\n        } else if (delta == temp) {\n            if (flag > a[i]) {\n                flag = a[i];\n            }\n        }\n    }\n    cout << flag << endl;\n    delete[] a;\n    delete[] b;\n    return 0;\n}\n```\n\n【容易出错的问题】\n\nC++ 和 Python 的浮点数除法运算输出结果的问题。总结如下表：\n\n| 运算\\语言 | C++ | Python 2 | Python 3 |\n| --- | --- | --- | --- |\n| `4 / 2` | `2` | `2` | `2` |\n| `5 / 2` | `2` | `2` | `2.5` |\n| `5.0 / 2` | `2.5` | `2.5` | `2.5` |\n\n## Problem 04. 亲和数\n\n### 题目部分\n\n【问题描述】\n\n古希腊数学家毕达哥拉斯在自然数研究中发现，220 的所有真约数(即不是自身的约数)之和为：   \n\n1+2+4+5+10+11+20+22+44+55+110＝284。\n\n而 284 的所有真约数为 1、2、4、71、 142，加起来恰好为 220。人们对这样的数感到很惊奇，并称之为亲和数。一般地讲，如果两个数中任何一个数都是另一个数的真约数之和，则这两个数就是亲和数。\n\n你的任务就编写一个程序，判断给定的两个数是否是亲和数。\n\n【输入形式】\n\n输入若干行数据（大于0），每行一个实例,包含两个整数A,B； 其中 0 <= A,B <= 600000 ;\n\n【输出形式】\n\n对于每个测试实例，如果 A 和 B 是亲和数的话输出 YES，否则输出 NO\n\n【样例输入】\n\n```\n220 284\n100 200\n```\n\n【样例输出】\n\n```\nYES\nNO\n```\n\n### 题解部分\n\n【思路】\n\n分别求两个数的「真约数」，判断是否等于对方。使用循环即可解决，这道题的数据规模不会导致双重循环超时 `Time Limit Exceeded` 的问题。这个题有一个情景不同，内核相同的变种，是 2021 秋季学期的「程序设计」课程的一个作业题：「牛数」（好像是叫这个名？）。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p04\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int num1 = 0, num2 = 0;\n    while (cin >> num1 >> num2) {\n        // the first number\n        int sum1 = 0;\n        for (int i = 1; i < num1; ++i) {\n            if (num1 % i == 0) {\n                sum1 += i;\n            }\n        }\n        if (sum1 != num2) {\n            cout << \"NO\" << endl;\n            continue;\n        }\n        // the second number\n        int sum2 = 0;\n        for (int i = 1; i < num2; ++i) {\n            if (num2 % i == 0) {\n                sum2 += i;\n            }\n        }\n        if (sum1 == num2 && sum2 == num1) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}\n\n```\n\n【需要注意的问题】\n\n两个数的真约数求和跟两个数的真约数本身不要搞混了。\n\n## Problem 05. 金币\n\n### 题目部分\n\n【问题描述】\n\n国王为他的忠诚的骑士支付金币。在他服役的第一天，骑士收到一枚金币。在接下来2天（第二天和第三天的服务），骑士每天收到2金币。在未来三天（第五，第四，和第六天的服务），骑士每天收到三金币。在未来四天（第七，第八，第九，和第十天的服务），骑士每天收到四金币。这一模式的付款方式将继续下去：在接下来的n天骑士每天将收到n枚金币，而在接接下来的n+1天每天将收到n+1枚金币，这里n是正整数。你的程序将确定在任何给定的天数（从第1天开始）支付给骑士的金币总数。\n\n【输入形式】\n\n输入包含至少一行，但不超过21行。输入的每一行包含一个测试案例的数据，即一个整数（1~10000），代表天数。\n\n【输出形式】\n\n每一行输出对应一个测试用例，由天数和支付给骑士的金币总数量组成，中间用空格分隔。\n\n【样例输入】\n\n```\n10\n6\n10000\n1000\n21\n22\n```\n\n【样例输出】\n\n```\n10 30\n6 14\n10000 942820\n1000 29820\n21 91\n22 98\n```\n\n### 题解部分\n\n【思路】\n\n用一个变量对当前天数进行计数，控制发金币的天数。用另外一个变量对发相同数量的金币的天数进行计数，控制相同金币天数形成一个等差数列。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p05\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int day = 0;\n    while (cin >> day) {\n        int coins = 0;\n        int cnt = 1;\n        int count_day = 1;\n        while (count_day <= day) {\n            for (int i = 0; i < cnt; ++i) {\n                coins += cnt;\n                count_day++;\n                if (count_day > day) {\n                    break;\n                }\n            }\n            cnt++;\n        }\n        cout << day << \" \" << coins << endl;\n    }\n    return 0;\n}\n\n```\n\n【需要注意的问题】\n\n需要多个计数变量，分别统计天数，不要弄混了。\n\n## Problem 06. 小A的计算器\n\n### 题目部分\n\n【题目描述】\n\n以往的操作系统内部的数据表示都是二进制方式，小A新写了一个操作系统，系统内部的数据表示为26进制，其中0-25分别由a-z表示。\n现在小A要在这个操作系统上实现一个计算器，这个计算器要能实现26进制数的加法运算。你能帮小A实现这个计算器吗？\n\n【输入形式】\n\n输入的第一行包括一个整数N(1<=N<=100)。\n接下来的N行每行包括两个26进制数x和y，它们之间用空格隔开，每个数的位数最多为10位,我们可以保证相加的结果的位数最多也是10位。每个数会用小A所设计的操作系统中的表示方法来表示，如：bsadfasdf。即每个数的各个位均由26个小写字母a-z中的一个来表示。\n\n【输出形式】\n\n输出x和y相加后的结果，结果也要用题目中描述的26进制数来表示。\n\n【样例输入】\n\n```\n4\nba cd\nc b\nb c\nba c\n```\n\n【样例输出】\n\n```\ndd\nd\nd\nbc\n```\n\n### 题解部分\n\n【思路】\n\n> 懒得写\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p06\n\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nlong long convert(char a[]) {\n    long long result = 0;\n    int length = (int) strlen(a);\n    long long product = 1;\n    for (int i = length - 1; i >= 0; i--) {\n        result += (a[i] - 'a') * product;\n        product *= 26;\n    }\n    return result;\n}\n\nint main() {\n    int n = 0;\n    cin >> n;\n    while (n--) {\n        char a[15];\n        char b[15];\n        char res[15];\n        cin >> a >> b;\n        long long A = convert(a);\n        long long B = convert(b);\n        long long C = A + B;\n        int num = 0;\n        while (C != 0) {\n            res[num++] = (C % 26 + 'a');\n            C /= 26;\n        }\n        for (int i = num - 1; i >= 0; i--) {\n            cout << res[i];\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n```\n\n【需要注意的问题】\n\n注意字符串和字符数组的处理。\n\n## Problem 07. 小丑排序\n\n### 题目部分\n\n【问题描述】\n\n你在信天翁马戏团（是的，它是由一群小丑组成）从事管理工作，你刚刚写完一个程序的输出是将他们的姓名按长度为非递减的方式排列，名称列表（使每名至少只要它之前的）。然而，你的老板不喜欢这种输出方式，而是希望输出出现更对称，较短的字符串在顶部和底部，而较长的字符串在中间。他的规则是，每一对名称都是在该列表的相对的两端，并且在该组中的第一个名字总是在列表的顶部。比如在下面的第一个例子中，Bo和Pat是第一对，Jean和Kevin是第二对，等等。\n\n【输入形式】\n\n输入由1到多个字符串集合组成，最后一行为0表示输入结束，每个集合开始于一个整数n，表示该集合字符串的个数，接下来n行由n个字符串按长度非递减的方式排列，每个集合至少包含一个但不超过15个字符串，每个字符串不超过25个字符。\n\n【输出形式】\n\n对于每个集合，第一行输出\"set-n\", n从1开始，接下来的若干行对应输入每个集合重新排列的结果，如样例所示。\n\n【样例输入】\n\n```\n7\nBo\nPat\nJean\nKevin\nClaude\nWilliam\nMarybeth\n6\nJim\nBen\nZoe\nJoey\nFrederick\nAnnabelle\n5\nJohn\nBill\nFran\nStan\nCece\n0\n```\n\n【样例输出】\n\n```\nset-1\nBo\nJean\nClaude\nMarybeth\nWilliam\nKevin\nPat\nset-2\nJim\nZoe\nFrederick\nAnnabelle\nJoey\nBen\nset-3\nJohn\nFran\nCece\nStan\nBill\n```\n\n### 题解部分\n\n【思路】\n\n按从上到下的顺序，奇数位置的名字从上往下排，偶数位置的名字从下往上排，最后直接输出整组数据就行。\n\n【Accepted 代码】\n\n```cpp\n// t02p07\n\n#include <iostream>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int counter = 1;\n    while (true) {\n        int n = 0;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        // auto *name = new string[n];\n        queue<string> up;\n        stack<string> down;\n        for (int i = 0; i < n; ++i) {\n            string tmp;\n            cin >> tmp;\n            if (i % 2 == 0) {\n                up.push(tmp);\n            } else {\n                down.push(tmp);\n            }\n        }\n        cout << \"set-\" << counter << endl;\n        counter++;\n        while (!up.empty()) {\n            cout << up.front() << endl;\n            up.pop();\n        }\n        while (!down.empty()) {\n            cout << down.top() << endl;\n            down.pop();\n        }\n    }\n    return 0;\n}\n\n```\n\n【需要注意的问题】\n\nC++ Standard Template Library 中 `stack` 的用法。以及不要忘记有多组数据要处理。\n\n## Problem 08. 数圈\n\n### 题目部分\n\n【问题描述】\n\n以1为中心，用2,3,4, ..., n, ..., n*n的数字围绕着中心输出数圈， 如若n=4，则\n\n7 8 9 10\n\n6 1 2 11\n\n5 4 3 12\n\n16 15 14 13\n\n【输入形式】\n\n一个整数n(1<=n<=10)\n\n【输出形式】\n\n数圈矩阵\n\n【样例输入】\n\n```\n5\n```\n\n【样例输出】\n\n```\n21 22 23 24 25\n20 7 8 9 10\n19 6 1 2 11\n18 5 4 3 12\n17 16 15 14 13\n```\n\n### 题解部分\n\n【思路】\n\n1. 正常思路，找出每一个位置上的「通项」表达，然后直接输出出来。\n2. 不正常思路，也是以下 AC 代码的写法，把最大规模的数圈矩阵写进代码，然后按输入数据输出对应规模。这种方法适用于数据规模不大的情况。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p08\n\n#include <iostream>\n\nusing namespace std;\n\nint rubbish_ring[10][10] = {\n        {73, 74, 75, 76, 77, 78, 79, 80, 81, 82},\n        {72, 43, 44, 45, 46, 47, 48, 49, 50, 83},\n        {71, 42, 21, 22, 23, 24, 25, 26, 51, 84},\n        {70, 41, 20, 7, 8, 9, 10, 27, 52, 85},\n        {69, 40, 19, 6, 1, 2, 11, 28, 53, 86},\n        {68, 39, 18, 5, 4, 3, 12, 29, 54, 87},\n        {67, 38, 17, 16, 15, 14, 13, 30, 55, 88},\n        {66, 37, 36, 35, 34, 33, 32, 31, 56, 89},\n        {65, 64, 63, 62, 61, 60, 59, 58, 57, 90},\n        {100, 99, 98, 97, 96, 95, 94, 93, 92, 91}\n};\n\nint main() {\n    int n = 0;\n    cin >> n;\n    if (n == 1) {\n        cout << 1 << endl;\n    } else if (n == 2) {\n        cout << 1 << \" \" << 2 << endl;\n        cout << 4 << \" \" << 3 << endl;\n    } else if (n % 2 != 0) {\n        for (int i = 4 - n / 2; i <= 4 + n / 2; ++i) {\n            for (int j = 4 - n / 2; j <= 4 + n / 2; ++j) {\n                if (j == 4 + n / 2) {\n                    cout << rubbish_ring[i][j];\n                } else {\n                    cout << rubbish_ring[i][j] << \" \";\n                }\n            }\n            cout << endl;\n        }\n    } else {\n        for (int i = 4 - (n / 2 - 1); i <= 4 + n / 2; ++i) {\n            for (int j = 4 - (n / 2 - 1); j <= 4 + n / 2; ++j) {\n                if (j == 4 + n / 2) {\n                    cout << rubbish_ring[i][j];\n                } else {\n                    cout << rubbish_ring[i][j] << \" \";\n                }\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n```\n\n【需要注意的问题】\n\n正常思路的话需要注意动态二维数组的创建和它的指针操作，如果你没有用 `vector` 的话。不正常思路就直接把答案写进代码里……\n\n## Problem 09. 锤子剪刀布\n\n### 题目部分\n\n【问题描述】\n\n大家应该都会玩“锤子剪刀布”的游戏。现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。\n\n【输入形式】\n\n输入第1行给出正整数N（<=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。\n\n【输出形式】\n\n输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。\n\n【样例输入】\n\n```\n10\nC J\nJ B\nC B\nB B\nB C\nC C\nC B\nJ B\nB C\nJ J\n```\n\n【样例输出】\n\n```\n5 3 2\n2 3 5\nB B\n```\n\n### 题解部分\n\n【思路】\n\n明明是石头剪刀布好不好，怎么到你这里就变成锤子了！\n\n把每一种情况分别进行比较，新建三个变量用于存储其中一方的胜、负、平局的次数，另外一方的胜负平局就是这一方的负胜平局次数。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p09\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n = 0;\n    cin >> n;\n    char *alpha = new char[n];\n    char *beta = new char[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> alpha[i] >> beta[i];\n    }\n    int alpha_win = 0, beta_win = 0, eqa = 0;\n    int a_c = 0, a_b = 0, a_j = 0, b_c = 0, b_b = 0, b_j = 0;\n    for (int i = 0; i < n; ++i) {\n        if (alpha[i] == 'C' && beta[i] == 'J') {\n            alpha_win++;\n            a_c++;\n        } else if (alpha[i] == 'C' && beta[i] == 'B') {\n            beta_win++;\n            b_b++;\n        } else if (alpha[i] == 'J' && beta[i] == 'B') {\n            alpha_win++;\n            a_j++;\n        } else if (alpha[i] == 'J' && beta[i] == 'C') {\n            beta_win++;\n            b_c++;\n        } else if (alpha[i] == 'B' && beta[i] == 'J') {\n            beta_win++;\n            b_j++;\n        } else if (alpha[i] == 'B' && beta[i] == 'C') {\n            alpha_win++;\n            a_b++;\n        } else if (alpha[i] == beta[i]) {\n            eqa++;\n        }\n    }\n    cout << alpha_win << \" \" << eqa << \" \" << beta_win << endl;\n    cout << beta_win << \" \" << eqa << \" \" << alpha_win << endl;\n    if (a_c <= a_b) {\n        if (a_j <= a_b) {\n            cout << \"B\" << \" \";\n        } else {\n            cout << \"J\" << \" \";\n        }\n    } else {\n        cout << \"C\" << \" \";\n    }\n    if (b_c <= b_b) {\n        if (b_j <= b_b) {\n            cout << \"B\";\n        } else {\n            cout << \"J\";\n        }\n    } else {\n        cout << \"C\";\n    }\n    return 0;\n}\n```\n\n【需要注意的问题】\n\n情况有点多，分类的时候不要漏了。\n\n## Problem 10. 绩点计算\n\n### 题目部分\n\n【问题描述】\n\n学校对本科生的成绩施行绩点制（GPA）。将学生的实际考分根据不同学科的不同学分按一定的公式进行计算。规定如下：\n\n实际成绩        绩点\n\n90-100          4.0\n\n85-89            3.7\n\n82-84            3.3\n\n78-81            3.0\n\n75-77            2.7\n\n72-74            2.3\n\n68-71            2.0\n\n64-67            1.5\n\n60-63            1.0\n\n60以下            0\n\n1.一门课程的学分绩点=该课绩点*该课学分\n\n2.总评绩点=所有学科绩点之和/所有课程学分之和\n\n现要求你编程求出某人的总评绩点(GPA)\n\n【输入形式】\n\n第一行 总的课程数n\n\n第二行 相应课程的学分（两个学分间用空格隔开）\n\n第三行 对应课程的实际得分\n\n此处输入的所有数字均为整数\n\n【输出形式】\n\n输出有一行，总评绩点，保留两位小数\n\n【样例输入】\n\n```\n5\n4 3 4 2 3\n91 88 72 69 56\n```\n\n【样例输出】\n\n```\n2.52\n```\n\n### 题解部分\n\n【思路】\n\n按部就班直接计算就可以，用一个数组存储学分，一个数组存储分数。然后根据分数段分情况计算，可以使用 `if...else if...else` 结构。保留两位小数，在 C++ 中使用 `#include <iomanip>` 然后设定精度，在 Python 中直接设定精度即可。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p10\n\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int n = 0;\n    cin >> n;\n    auto *credit = new double[n];\n    auto *score = new double[n];\n    auto *point = new double[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> credit[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> score[i];\n        if (score[i] < 60) {\n            point[i] = 0;\n        } else if (score[i] >= 60 && score[i] <= 63) {\n            point[i] = 1.0;\n        } else if (score[i] >= 64 && score[i] <= 67) {\n            point[i] = 1.5;\n        } else if (score[i] >= 68 && score[i] <= 71) {\n            point[i] = 2.0;\n        } else if (score[i] >= 72 && score[i] <= 74) {\n            point[i] = 2.3;\n        } else if (score[i] >= 75 && score[i] <= 77) {\n            point[i] = 2.7;\n        } else if (score[i] >= 78 && score[i] <= 81) {\n            point[i] = 3.0;\n        } else if (score[i] >= 82 && score[i] <= 84) {\n            point[i] = 3.3;\n        } else if (score[i] >= 85 && score[i] <= 89) {\n            point[i] = 3.7;\n        } else if (score[i] >= 90 && score[i] <= 100) {\n            point[i] = 4.0;\n        }\n    }\n    double total = 0, credit_total = 0;\n    for (int i = 0; i < n; ++i) {\n        total += credit[i] * point[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        credit_total += credit[i];\n    }\n    total /= credit_total;\n    delete[] credit;\n    delete[] score;\n    delete[] point;\n    cout << fixed << setprecision(2) << total << endl;\n    return 0;\n}\n\n```\n\n【需要注意的问题】\n\n浮点数除法结果的问题。\n\n## Problem 11. 最小的k个数\n\n### 题目部分\n\n【问题描述】\n\n输入n个整数，找出其中最小的k（k<=n）个不同数。例如输入4,5,1,6,1,7,3,8这8个数字，则最小的4个数字是1,3,4,5。\n\n【输入形式】\n\n每个测试案例包括2行：\n\n第一行为2个整数n，k(1<=n，k<=200000)，表示数组的长度。\n\n第二行包含n个整数，表示这n个数，数组中的数的范围是[0,1000 000 000]。\n\n【输出形式】\n\n对应每个测试案例，输出最小的k个数，并按从小到大顺序打印(如果不存在k个不同的数，则按照实际数量进行输出)。\n\n【样例输入】\n\n```\n8 4\n4 5 1 6 2 7 3 8\n```\n\n【样例输出】\n\n```\n1 2 3 4\n```\n\n【训练提示】\n\n1、数的范围从0到1000000000，使用数组记录那些数出现过就不是太合适\n\n2、需要去除重复的数，需要从小到大排序----set就是一个不错的选择\n\n### 题解部分\n\n【思路】\n\n你这训练提示……我就偏要用数组。用一个数组存储数据，然后直接从小到大排序。然后从头开始遍历，先直接输出第一个数，然后从第二个数开始，如果当前数字跟前一个数不一样，那我就输出，同时计数器加一，直到计数器达到 k 的数量停止程序。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p11\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n = 0, k = 0;\n    cin >> n >> k;\n    int *a = new int[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(a, a + n);\n    int cnt = 1;\n    cout << a[0] << \" \";\n    for (int i = 1; i < n; ++i) {\n        if (a[i] != a[i - 1]) {\n            cout << a[i] << \" \";\n            cnt++;\n        }\n        if (cnt == k) {\n            break;\n        }\n    }\n    return 0;\n}\n\n```\n\n【需要注意的问题】\n\n按提示用 `map` 也行吧，我没用过。用过的可以 pull request。\n\n## Problem 12. 拼写检查\n\n### 题目部分\n\n【问题描述】\n\n作为一个新的拼写检查程序开发团队的成员，您将编写一个模块，用已知的所有形式正确的词典来检查给定单词的正确性。\n如果字典中没有这个词，那么可以用下列操作中的一个来替换正确的单词（从字典中）：\n\n1.从单词中删除一个字母；\n\n2.用一个任意字母替换单词中的一个字母；\n\n3.在单词中插入一个任意字母。\n\n你的任务是编写一个程序，为每个给定的单词找到字典中所有可能的替换。\n\n【输入形式】\n\n输入的第一部分包含所有字典中的词，每个单词占用一行，以一个单一字符“#”作为结束。所有单词都不相同，字典中至多1000个单词。\n\n接下来的部分包含所有需要进行检查的单词，同样每个单词占用一行。这部分也以一个单一字符“#”作为结束。至多有50个单词需要检查。\n\n在输入中所有的单词（字典中的和需要检查的）都仅由小写字母组成，每个最多包含15个字符。\n\n【输出形式】\n\n对于每个在输入中出现的单词，按照它们在输入的第二部分出现的顺序输出一行。如果该单词是正确的（也就是说它包含在字典中）则输出信息：“is correct”；如果该单词不正确，则首先输出该单词，然后输入符号':'（冒号），之后空一格，写出它所有可能的替代，以空格分隔。这些替代的单词按照它们在字典中（输入的第一部分）出现的顺序写出。如果没有可替代的单词，则在冒号后面直接输出换行。\n\n【样例输入】\n\n```\ni\nis\nhas\nhave\nbe\nmy\nmore\ncontest\nme\ntoo\nif\naward\n#\nme\naware\nm\ncontest\nhav\noo\nor\ni\nfi\nmre\n#\n```\n\n【样例输出】\n\n```\nme is correct\naware: award\nm: i my me\ncontest is correct\nhav: has have\noo: too\nor:\ni is correct\nfi: i\nmre: more me\n```\n\n### 题解部分\n\n【思路】\n\n没思路，不用看了，下一题。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t02p12\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool similar(string long_str, string short_str) {\n    int long_in = (int) long_str.length();\n    int short_in = (int) short_str.length();\n    string tmp;\n    for (int i = 0; i < short_in; ++i) {\n        if (long_str[i] != short_str[i]) {\n            tmp = short_str.substr(0, i);\n            tmp += long_str[i] + short_str.substr(i, short_in - i);\n            if (tmp == long_str) {\n                return true;\n            }\n        }\n    }\n    tmp = short_str + long_str[long_in - 1];\n    if (tmp == long_str) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    vector<string> dictionary;\n    vector<string>::iterator it;\n    string word;\n    string dic;\n    bool flag;\n    int sub;\n    while (true) {\n        cin >> dic;\n        if (dic == \"#\") {\n            break;\n        }\n        dictionary.push_back(dic);\n    }\n    while (true) {\n        cin >> word;\n        if (word == \"#\") {\n            break;\n        }\n        flag = false;\n        for (it = dictionary.begin(); it != dictionary.end(); it++) {\n            dic = *it;\n            if (dic == word) {\n                cout << word << \" is correct\";\n                flag = true;\n            }\n        }\n        if (!flag) {\n            cout << word << \":\";\n            for (it = dictionary.begin(); it != dictionary.end(); it++) {\n                dic = *it;\n                sub = dic.length() - word.length();\n                if (sub == 0) {\n                    for (int i = 0; i < (int) dic.length(); ++i) {\n                        if (dic[i] != word[i]) {\n                            string temp = word;\n                            temp[i] = dic[i];\n                            if (temp == dic) {\n                                cout << \" \" << dic;\n                            }\n                            break;\n                        }\n                    }\n                } else if (abs(sub) == 1) {\n                    if (dic.length() < word.length()) {\n                        if (similar(word, dic)) {\n                            cout << \" \" << dic;\n                        }\n                    } else {\n                        if (similar(dic, word)) {\n                            cout << \" \" << dic;\n                        }\n                    }\n                }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n```\n\n【需要注意的问题】\n\n输入输出很繁杂，小心别弄错了。\n\n## 本文许可协议\n\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.\n","tags":["开发与应用"]},{"title":"HNU 夏季学期「程序设计训练 2022」 课程题解（一）","url":"/2022/06/22/2022-06-22-HNU夏季学期程序设计题解一/","content":"\n# HNU 夏季学期「程序设计训练 2022」 课程题解（一）\n\n## 前言\n\n> 「输入两个整数 a 和 b，输出它们的和。」\n>           —— A+B Problem\n\n本题解中的题目描述文字格式全部按照题目原文，描述部分的排版和题解作者无关。\n\n## 代码\n\n代码项目和文件存放于仓库中：\n\n[https://github.com/Chen-Rain/Pitaya](https://github.com/Chen-Rain/Pitaya)\n\n如果无法打开请自行检查网络配置。\n\n## Problem 01. 众数\n\n### 题目部分\n\n【问题描述】\n\n一组数据中出现最多的数，称为众数。比如\n\n1 2 3 3\n\n众数为3。一组数据中也可能有多个众数，以最先出现的作为众数。比如\n\n2 2 3 3\n\n众数为2。\n\n问题是一组按升序排好的数据，指出它的众数。\n\n【输入形式】\n\n有多组测试数据（不超过100组测试数据）。\n\n每组测试数据占两行，第一行是正整数N：表示这组测试数据中数据项数。\n\n第二行是N个用空格隔开的正整数，表示这组测试数据的数据元素。每个数据元素都不大于10000。\n\nN=0，表示输入结束，并且不需要处理。\n\n40%的测试数据N 1 ≤N≤ 10；\n\n30%的测试数据N 10 < N≤ 100；\n\n20%的测试数据N 100 < N≤ 1000；\n\n10%的测试数据N 1000 < N≤ 10000；\n\n【输出形式】\n\n对于每组测试数据，输出一行包含一个正整数：对应的众数。\n\n【样例输入】\n\n```\n4\n1 2 3 3\n4\n2 2 3 3\n0\n```\n\n【样例输出】\n\n```\n3\n2\n```\n\n### 题解部分\n\n【思路】\n\n用整型数组存储输入的要求众数的数据。根据单独输入的数字 `n` 来确定动态数组的大小。由于数组已经升序排列好了，所以不用考虑数字大小关系的问题。新建一个数组 `c[i]` 用于存储数字 `i` 的众数，这个数组应当开大一些，确保测试数据规模中的所有数字都可以在其中表示。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p01\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n = 0;\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        int *a = new int[n];\n        int c[10001] = {0};\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            c[a[i]]++;\n        }\n        int max = 0;\n        int result = 0;\n        for (int i = 0; i < 10001; ++i) {\n            if (c[i] > max) {\n                max = c[i];\n                result = i;\n            }\n        }\n        cout << result << endl;\n        delete[] a;\n    }\n    return 0;\n}\n```\n\nPython 3\n\n```python\n# encoding utf-8\n# t01p01\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        a = list(map(int, input().split()))\n        c = [0] * 999999  # 用于存储数字 i 的重复个数\n        for i in range(n):\n            c[int(a[i])] = c[int(a[i])] + 1\n        max_num = 0\n        result = 0\n        for i in range(999999):\n            if int(c[i]) > max_num:\n                max_num = int(c[i])\n                result = int(i)\n        print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n【遇到的一些问题】\n\n就是这 Python 的输入问题有点不方便。如果一定要使用 Python 答题的话需要仔细调整输入方式，防止在本地测试的时候可以通过，但是提交之后 WA。\n\n## Problem 02. 开关与灯\n\n### 题目部分\n\n【问题描述】\n\n给定n个开关和m个灯，第i个开关只能打开部分灯。矩阵a包含n行m列，当aij=1时表示开关i可以打开灯j，否则aij=0。\n\n开始时所有的m个灯都是关着的。\n\n开关只能从状态\"关\"到\"开\"。这意味着，对于每个可以打开某个灯的开关，无论你按多少次，这个灯都是开的。\n\n确保当你按下所有开关时，所有的灯都能打开，考虑是否可以忽略其中某个开关也能打开所有的灯。\n\n你的任务是确定是否存在这样的开关可以忽略，而使用其余的n-1个开关来打开所有m个灯。\n\n【输入形式】\n\n输入第1行包含两个整数n和m(1<=n, m<=2000)，表示开关的数量和灯的数量。\n\n接下来的n行，每行包含m个字符，字符aij=1时表示开关i可以打开灯j，否则aij=0。\n\n【输出形式】\n\n如果存在这样的可以忽略的开关，而使用其他n-1个开关打开所有的m个灯，输出\"YES\"，否则输出\"NO\"。\n\n【样例输入】\n\n```\n4 5\n10101\n01000\n00111\n10000\n```\n\n【样例输出】\n\n```\nYES\n```\n\n### 题解部分\n\n【思路】\n\n使用矩阵来存储开关与灯的对应关系，横向输入的时候可以用字符数组，也可以用字符串。然后每一列判断可以开灯的个数。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p02\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    int n, m, flag, i, j;\n    char x[2010];\n    int a[20][20];\n    int sum[2010];\n    memset(a, 0, sizeof(a));\n    memset(sum, 0, sizeof(sum));\n    cin >> n >> m;\n    getchar();\n    for (i = 1; i <= n; i++) {\n        cin.getline(x, 2010);\n        // gets(x);\n        for (j = 1; j <= m; j++) {\n            a[i][j] = x[j - 1] - '0';\n            if (a[i][j] == 1) {\n                sum[j]++;\n            }\n        }\n    }\n    flag = 0;\n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= m; j++) {\n            if (sum[j] - a[i][j] == 0) {\n                break;\n            }\n        }\n        if (j == m + 1) {\n            flag = 1;\n        }\n    }\n    if (flag) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n```\n\n【遇到的一些问题】\n\n这道题容易出错的一点是，以为只要有矩阵的一列的数量大于 1 就可以满足去掉的条件，实际上还是要注意要判断去掉那一行之后还能不能保证所有的灯全部亮。\n\n## Problem 03. 可删除的点\n\n### 题目部分\n\n【问题描述】\n\n平面上有n个不同的点，没有在Y轴的点，检查是否存在这样一个点，将其删除后其余所有的点均位于Y轴的同一边。\n\n【输入形式】\n\n输入第一行包含一个正整数n(2<=n<=105)。\n\n接下来的n行，包含所有点的坐标，第i行包含两个整数xi和yi(|xi|、|yi|<=109，xi<>0)。\n\n【输出形式】\n\n如果存在这样的点，则输入\"Yes\"，否则输出\"No\"。\n\n【样例输入】\n\n```\n3\n1 1\n-1 -1\n2 -1\n```\n\n【样例输出】\n\n```\nYes\n```\n\n### 题解部分\n\n【思路】\n\n均在 y 轴同一边的点满足 x 轴全是正数或者全是负数。所以输入的时候最少只需要给一个变量存储所有点的 y 坐标即可，不用处理。对所有点的 x 坐标进行判断，设立一个变量记录一边的点的数量。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p03\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n = 0;\n    cin >> n;\n    int *x = new int[n];\n    int *y = new int[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    int x_negative = 0, x_positive = 0;\n    for (int i = 0; i < n; ++i) {\n        if (x[i] < 0) {\n            x_negative++;\n        } else {\n            x_positive++;\n        }\n    }\n    if ((x_negative == 1 || x_positive == 1) || (x_negative == 0 && x_positive != 0) ||\n        (x_positive == 0 && x_negative != 0)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n```\n\n【可能出错的地方】\n\n「在 y 轴的同一边」到底是比较 x 坐标还是比较 y 坐标呢？\n\n## Problem 04. 字符串反转 3\n\n### 题目部分\n\n【问题描述】\n\n给出一个字符串，请将其每个单词反转后输出。\n\n【输入形式】\n\n输入第一行为一个正整数N，表示测试用例数，接下来的N行，每行一个字符串。\n\n【输出形式】\n\n输出N行，每行对应一个反转后的字符串。\n\n【样例输入】\n\n```\n3\nolleh !dlrow\nm'I morf .unh\nI ekil .tae\n```\n\n【样例输出】\n\n```\nhello world!\nI'm from hnu.\nI like eat.\n```\n\n### 题解部分\n\n【思路】\n\n第一眼，喔，经典字符串反转。第二眼，喔还带空格，要考虑一下输入问题。然后反转字符串第一时间想到的就是可以使用「栈」，`stack`，不过如果你第一感觉是用 `reverse()` 函数，那也没问题，不过就要考虑分段的问题了。这道题我提交的解法是使用了 `stack`，把字符串中的每一个字符进行判断，然后推入栈中，遇到空格的时候说明应该分词了，就把栈弹出，直至清空整个栈，如此往复至处理完所有数据。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p04\n\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n = 0;\n    cin >> n;\n    cin.get();\n    while (n--) {\n        string input;\n        getline(cin, input);\n        stack<char> out;\n        for (char &i: input) {\n            if (i == ' ') {\n                while (!out.empty()) {\n                    cout << out.top();\n                    out.pop();\n                }\n                cout << \" \";\n                continue;\n            }\n            out.push(i);\n        }\n        while (!out.empty()) {\n            cout << out.top();\n            out.pop();\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n【可能遇到的问题】\n\n在使用 C++ 解答的时候，注意栈的大小，小心遗漏。使用 Python 解答的时候注意字符串输入的时候的问题，容易出现格式和数据类型对不上的问题。\n\n## Problem 05. n，还是n\n\n### 题目部分\n\n【问题描述】\n\n输出 包含n 或者是n的倍数的所有数。\n\n【输入形式】\n\n正整数 m,n（0 < m，n<1000000）\n\n【输出形式】\n\n从小到大排列的不大于 m 的特殊正整数（包含n，或者是n的倍数）。\n\n【样例输入 1】\n\n```\n20 7\n```\n\n【样例输出 1】\n\n```\n7 14 17\n```\n\n【样例输入 2】\n\n```\n200 11\n```\n\n【样例输出 2】\n\n```\n11 22 33 44 55 66 77 88 99 110 111 112 113 114 115 116 117 118 119 121 132 143 154 165 176 187 198\n```\n\n【样例说明】\n\n包含n的数可以考虑使用字符串查找解决\n\n### 题解部分\n\n【思路】\n\n首先查找字符串，如果找到就直接输出；如果没有找到再考虑整除。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p05\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int m = 0, n = 0;\n    cin >> m >> n;\n    for (int i = 1; i <= m; ++i) {\n        string s = to_string(i);\n        string tar = to_string(n);\n        if ((i % n == 0) || (s.find(tar) != string::npos)) {\n            cout << i << \" \";\n        }\n    }\n    return 0;\n}\n```\n\n【可能遇到的问题】\n\n如果使用每一位数字对 10 取模的方法来判断的话就没有办法找到数字中包含两位或两位以上的给定数字的数，无法通过全部样例。\n\n## Problem 06. 字符串排序\n\n### 题目部分\n\n【问题描述】\n\n定义一个字符串的无序度为所有位置后面的字母比该位置的字母小的总数之和。比如\"DAABEC''这个字符串的无序度是5，因为D后面有4个位置比它小（AABC），E后面有1个比它小（C），其它位置后面没有比自己小的。\" AACEDGG \"的无序度为1（E后面有一个D比它小）。\" ZWQM \"的无序度为6，每个位置后面所有的字母都比它小。\n现在你的任务是给定一些字符串（只由大写字母组成），把他们按照无序度从小到大排序，如果无序度一样，那么就按照输入的相对顺序排序。\n\n【输入形式】\n\n单组测试数据。\n第一行有两个整数n(0 < n <= 50)和m (0 < m <= 100)，分别表示输入的字符串的长度和字符串的个数。\n接下来m行，每一行包含一个长度为n的字符串，只由大写字母组成。\n\n【输出形式】\n\n输出m行，表示排序之后的字符串。\n\n【样例输入】\n\n```\n10 6\nAACATGAAGG\nTTTTGGCCAA\nTTTGGCCAAA\nGATCAGATTT\nCCCGGGGGGA\nATCGATGCAT\n```\n\n【样例输出】\n\n```\nCCCGGGGGGA\nAACATGAAGG\nGATCAGATTT\nATCGATGCAT\nTTTTGGCCAA\nTTTGGCCAAA\n```\n\n### 题解部分\n\n【思路】\n\n无序度的算法可以是冒泡排序的思路。在数据存储方面，建立了结构体来存储字符串和对应的无序度。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p06\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Series {\n    string str;\n    int count{};\n    int order{};\n};\n\nbool cmp(const Series &a, const Series &b) {\n    if (a.count < b.count) {\n        return true;\n    } else {\n        if (a.count == b.count) {\n            if (a.order < b.order) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n}\n\nint main() {\n    int n = 0, m = 0;\n    cin >> n >> m;\n    auto *x = new Series[m];\n    char y;\n    for (int i = 0; i < m; ++i) {\n        cin >> x[i].str;\n        x[i].count = 0;\n        x[i].order = 0;\n    }\n    for (int i = 0; i < m; ++i) {\n        for (int k = 0; k < n; ++k) {\n            y = x[i].str[k];\n            for (int j = k + 1; j < n; ++j) {\n                if (x[i].str[j] < y) {\n                    x[i].count++;\n                }\n            }\n        }\n    }\n    sort(x, x + m, cmp);\n    for (int i = 0; i < m; ++i) {\n        cout << x[i].str << endl;\n    }\n    return 0;\n}\n```\n\n## Problem 07. 三角形的面积\n\n### 题目部分\n\n【问题描述】\n\n已知三角形的三个顶点的坐标，求该三角形的面积。\n\n【输入形式】\n\n有多组测试数据。\n\n每组测试数据占一行，6个用空格分隔开的浮点数：x1,y1,x2,y2,x3,y3。表示三角形三个顶点的坐标。\n\n一行6个0（形如0 0 0 0 0 0），表示输入结束，并且不需要处理。\n\n40%的顶点坐标 -10 ≤ xi,yi≤ 10；i=1,2,3\n\n30%的顶点坐标 -100 ≤ xi,yi≤ 100；i=1,2,3\n\n20%的顶点坐标 -1000 ≤ xi,yi≤ 1000；i=1,2,3\n\n10%的顶点坐标 -10000 ≤ xi,yi≤ 10000；i=1,2,3\n\n【输出形式】\n\n对于每组测试数据，输出对应三角形面积，保留小数点后6位。\n\n【输入样例】\n\n```\n1 2 3 4 -2 8\n0 0 0 1 1 0\n0 0 0 0 0 0\n```\n\n【输出样例】\n\n```\n9.000000\n0.500000\n```\n\n【解题技巧】\n\n海伦公式、向量叉乘\n\n### 题解部分\n\n【思路】\n\n解题技巧已经提到了，计算三角形面积可以使用海伦公式，在这个题里面是一种比较简单的方式。海伦公式如下：\n\n$ p = \\frac{a + b + c}{2} $，$ S = \\sqrt{p(p - a)(p - b)(p - c)} $\n\n另外，技巧提示里说的向量叉乘好像没有用到（？），不确定。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// T01P07\n\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    double x[3] = {0}, y[3] = {0};\n    while (true) {\n        cin >> x[0] >> y[0] >> x[1] >> y[1] >> x[2] >> y[2];\n        if (x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0 && x[2] == 0 && y[2] == 0) {\n            break;\n        }\n        double a = sqrt(pow(x[1] - x[0], 2) + pow(y[1] - y[0], 2));\n        double b = sqrt(pow(x[2] - x[1], 2) + pow(y[2] - y[1], 2));\n        double c = sqrt(pow(x[0] - x[2], 2) + pow(y[0] - y[2], 2));\n        double p = (a + b + c) / 2;\n        double area = sqrt(p * (p - a) * (p - b) * (p - c));\n        cout << fixed << setprecision(6) << area << endl;\n    }\n    return 0;\n}\n```\n\n【容易遇到的问题】\n\n保留 6 位小数；另外做除法运算的时候要确保是浮点型数据在运算，否则只能得到整除的结果。\n\n## Problem 08. 循环数\n\n### 题目部分\n\n【问题描述】\n\n循环数是n位长度的整数，当乘以从1到n的任何整数时，产生原始数字的“循环”。也就是说，如果考虑最后一个数字之后的数字“绕”回到第一个数字，两个数字中的数字序列将是相同的，尽管它们可能从不同的位置开始。例如，数字142857是循环的，如下表所示： \n\n142857 *1 = 142857\n142857 *2 = 285714\n142857 *3 = 428571\n142857 *4 = 571428\n142857 *5 = 714285\n142857 *6 = 857142 \n\n编写一个程序来确定数字是否是循环数。\n\n【输入形式】\n\n输入一个数，长度在2到60位之间(请注意，前面的零不应该被删除，它们被认为是确定n的大小和计数的一部分，因此，“01”是一个两位数的数字，与“1”是一个一位数的数字不同。) 。\n\n【输出形式】\n\n对于每个输入，输出一行(Yes或No)标识它是否是循环数。 \n\n【样例输入】\n\n```\n142857\n```\n\n【样例输出】\n\n```\nYes\n```\n\n【特别感谢】\n\n特别感谢计科 2101 班 lsk 同学提供的测试数据集导致部分同学的使用数字进行处理的代码直接 WA 了。\n\n### 题解部分\n\n【思路】\n\n用字符串存储要判断的数字串，然后把它变成两倍连在一起，用数字分别加倍，在两倍长的字符串中寻找子串，如果都能找到，说明是循环数。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p08\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string num, judge;\n    cin >> num;\n    judge = num + num;\n    int length = num.length();\n    bool flag = true;\n    string com = num;\n    string::size_type found;\n    for (int i = 2; i <= length; ++i) {\n        int temp = 0;\n        for (int j = length - 1; j >= 0; --j) {\n            temp = (num[j] - '0') * i + temp;\n            com[j] = temp % 10 + '0';\n            temp /= 10;\n        }\n        found = judge.find(com);\n        if (found == string::npos) {\n            flag = false;\n            break;\n        }\n    }\n    if (flag) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n```\n\n## Problem 09. 电能消耗\n\n### 题目部分\n\n【问题描述】\n\n汤姆对他最喜欢的笔记本电脑的耗电量很感兴趣。他的笔记本电脑有三种模式。在正常模式下，笔记本电脑每分钟消耗P1瓦。在汤姆最后一次移动鼠标或触摸键盘后的T1分钟，屏幕保护程序启动，每分钟的功耗变化为P2瓦。最后，从屏幕保护程序启动到T2分钟后，笔记本电脑切换到“睡眠”模式，每分钟消耗P3瓦。 当笔记本电脑处于第二或第三模式时，如果汤姆移动鼠标或触摸键盘，则切换到第一种(正常)模式。 汤姆使用笔记本电脑工作的时间可以分为n个时间间期[l1, r1]、[l2, r2]、...、[ln, rn]。在每个间期，汤姆连续移动鼠标并按下键盘。 在间期之间，汤姆什么都不做。请找出在间期[l1, rn]笔记本电脑的总耗电量。\n\n【输入形式】\n\n第一行包含6个整数n、P1、P2、P3、T1、T2(1<=n<=100，0<=P1、P2、P3<=100，1<=T1、T2<=60)。接下来的n行包含了汤姆工作的期间，第i行是两个用空格分隔的整数li和ri(0<=li<=ri<=1440, 当i< n时ri< li+1）, 表示工作期间的开始时间和结束时间。\n\n【输出形式】\n\n输出总的耗电量。\n\n【输入样例】\n\n```\n2 8 4 2 5 10\n20 30\n50 100\n```\n\n【输出样例】\n\n```\n570\n```\n\n### 题解部分\n\n【思路】\n\n> 稍后补充\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p09\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n = 0, p1 = 0, p2 = 0, p3 = 0, t1 = 0, t2 = 0;\n    cin >> n >> p1 >> p2 >> p3 >> t1 >> t2;\n    int time[n][2];\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            cin >> time[i][j];\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        ans += (time[i][1] - time[i][0]) * p1;\n        int get;\n        if (i == n - 1) {\n            break;\n        }\n        get = time[i + 1][0] - time[i][1];\n        if (get >= t1) {\n            ans += t1 * p1;\n            get -= t1;\n            if (get >= t2) {\n                ans += t2 * p2;\n                get -= t2;\n                ans += get * p3;\n            } else {\n                ans += get * p2;\n            }\n        } else {\n            ans += get * p1;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n## Problem 10. IP 地址\n\n### 题目部分\n\n【问题描述】\n\n一个IP地址由32位二进制的数组成，比如：\n\n11111111111111111111111100000000（2）\n\n为了便于记忆，我们将8个二进制位用一个十进制数表示，一个IP地址由四个十进制数表示，上述的IP地址表示为：\n\n255.255.255.0\n\n现在给你一个上述形式的IP地址，请回答IP地址的32个二进制位中，有多少位是1。\n\n如IP地址为255.255.255.0，其中24位是1。\n\n【输入形式】\n\n有多组测试数据。\n\n测试数据第一行是一个正整数T，表示测试数据组数。\n\n每组测试数据是一个IP地址，形式为：\n\nIP1.IP2.IP3.IP4\n\n其中0 ≤IP1,IP2,IP3,IP4≤ 255,用十进制表示。每个IP地址不保证是实用IP地址。\n\n40%的测试数据组数T  10≤T≤ 102；\n\n30%的测试数据组数T  102≤T≤ 103；\n\n20%的测试数据组数T  103≤T≤ 104；\n\n10%的测试数据组数T  104≤T≤ 105；\n\n【输出形式】\n\n对于每个IP地址，输出一行包含一个非负整数：该IP地址的32个二进制位中，1的位数。\n\n【样例输入】\n\n```\n5\n255.255.255.0\n127.0.0.1\n0.0.0.1\n1.2.3.4\n0.0.0.0\n```\n\n【样例输出】\n\n```\n24\n8\n1\n5\n0\n```\n\n### 题解部分\n\n【思路】\n\n读入 IP 地址，分成四个十进制的整数，然后分别转换成二进制数，统计总的数字 1 的个数。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p10\n\n#include <iostream>\n#include <cstdio>\n#include <string>\n\nusing namespace std;\n\nstring to_bin(int num) {\n    string bin_result;\n    while (num > 0) {\n        bin_result = to_string(num % 2) + bin_result;\n        num /= 2;\n    }\n    return bin_result;\n}\n\nint main() {\n    int n = 0;\n    cin >> n;\n    while (n--) {\n        int a = 0, b = 0, c = 0, d = 0;\n        scanf(\"%d.%d.%d.%d\", &a, &b, &c, &d);\n        // cout << a << b << c << d << endl;\n        string bin_a = to_bin(a);\n        string bin_b = to_bin(b);\n        string bin_c = to_bin(c);\n        string bin_d = to_bin(d);\n        int num = 0;\n        for (char i : bin_a) {\n            if (i == '1') {\n                num++;\n            }\n        }\n        for (char i : bin_b) {\n            if (i == '1') {\n                num++;\n            }\n        }\n        for (char i : bin_c) {\n            if (i == '1') {\n                num++;\n            }\n        }\n        for (char i : bin_d) {\n            if (i == '1') {\n                num++;\n            }\n        }\n        cout << num << endl;\n    }\n    return 0;\n}\n```\n\n【可能遇到的问题】\n\n怎么把这个 IP 地址分成四个整数？截取一小段[我](https://github.com/Chen-Rain)和 [@Brick](https://github.com/Brick-Loo) 聊天记录如下：\n\nRain: 话说怎么输入一串数字的时候用「.」分隔开几个整数？\n\nBrick: 没懂你意思，就是说用.代替空格来分隔数字？\n\nRain: 对\n\nRain: 比如这样，123.456.789.10\n\nRain: 我要把这几个数提取出来\n\nBrick: 唔，用 get 函数？\n\nBrick: 我印象中有一个重载是可以设置分隔符的\n\nBrick: 或者你直接一个一个 peek 看看是不是点 /doge（离谱型做法）\n\nBrick: （这个应该不行吧）\n\nBrick: 不过这样的话\n\nBrick: 喔喔 get 好像可以\n\nRain: 你这个我 peek 完之后还要把它搞成一个数字啊喂\n\nRain: 好 我吃完饭看看\n\nBrick: /doge\n\nBrick: 那可以直接存进数组然后再用 ASCII 偏移和位数加进一个 int 里面 /doge\n\nBrick: 太骚了\n\nBrick: 指 peek 的方法\n\nRain: 那我考虑一下这个\n\nRain:\n```cpp\nfor (char &i : s) {\n    getchar(i);\n}\n```\n\nRain: /emoji\n\nBrick: 诶\n\nBrick: 其实可以整个串读到一个数组\n\nBrick: 然后从最后开始\n\nBrick: 往前\n\nBrick: 如果是数字的话就乘个 10 再加进来\n\nBrick: 如果不是数字对话就再往前一位存到新的 int 里面\n\nBrick: 你是这个意思吗（引用那串代码）\n\nRain: 我是一个字符一个字符的读取\n\nRain: 诶 好像是这个意思\n\n然后过了一个晚上……\n\nRain: @Brick 我们好像想复杂了\n\nRain: 这不就直接把点给搞掉了嘛\n\n```c\nscanf(\"%d.%d.%d.%d\", &a, &b, &c, &d);\n```\n\nRain: 垃圾吸艹\n\nBrick: ？？？\n\nBrick: 没学过这种操作\n\nBrick: 还是 c 比较牛\n\nRain: 如果这个点换成其他字符也 OK\n\nRain: 诶 完美（）\n\nBrick: 好活 看来我假期得学手 c\n\n所以我一开始绕了一大圈，绕过了从输入的方法上解决数字分段的问题……但是后来又仔细一想，C++ 里面也有这种输入方式，只要用一个字符变量存储点就行了……\n\n属实离谱。\n\n## Problem 11. 平均方差\n\n### 题目部分\n\n【问题描述】\n\n一个数列的平均方差是指数列中的每个元素与数列的平均值的差的平方和的平均值，比如下面数列：\n\n1 2 3 4 5 6 7\n\n其平均值为4，每个元素与平均值的差的平方为\n\n9 4 1 0 1 4 9\n\n其平方和为28，所以该数列的平均方差为4。\n\n对给定的数列，求出其平均方差。\n\n【输入形式】\n\n有多组测试数据。\n\n每组测试数据第一行是一个正整数N，表示数列中元素个数，接下来一行N个用空格分隔开的正整数，表示数列的N个元素，每个元素的值都是不大于500的正整数。\n\nN=0表示输入结束，并且不需要处理。\n\n40%的数列元素个数N 1 ≤ N≤ 10；\n\n30%的数列元素个数N 1 ≤ N≤ 100；\n\n20%的数列元素个数N 1 ≤ N≤ 1000；\n\n10%的数列元素个数N 1 ≤ N≤ 10000；\n\n【输出形式】\n\n对于每组测试数据，输出一个整数：平均方差。平均方差不是整数的，输出其向下取整的整数。比如平均方差是4.5，输出4。\n\n【样例输入】\n\n```\n7\n1 2 3 4 5 6 7\n4\n1 2 3 4\n0\n```\n\n【样例输出】\n\n```\n4\n1\n```\n\n### 题解部分\n\n【思路】\n\n> 这是一个水题。 —— OI 名言\n\n按着题目的方法算就行了，用一两个循环，可以解决。用 Python 的选手注意一下把输入的循环控制住，用 C++ 的选手注意把整数和浮点数的运算处理好。\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p11\n\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    while (true) {\n        int n = 0;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        int *a = new int[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        double average = 0, sum = 0;\n        for (int i = 0; i < n; ++i) {\n            sum += a[i];\n        }\n        average = sum / n;\n        double ss = 0;\n        for (int i = 0; i < n; ++i) {\n            ss += (a[i] - average) * (a[i] - average);\n        }\n        cout << floor(ss / n) << endl;\n    }\n    return 0;\n}\n```\n\n## Problem 12. 内存管理\n\n### 题目部分\n\n【问题描述】\n\n离第一个操作系统HNU-OS发布已经没有多少时间了，但它的一些组件还没有完成，内存管理器就是其中之一。根据开发人员的计划，在第一个版本中，内存管理器将非常简单和直观。它将支持三个操作： \n\nalloc n —— 分配n个字节内存，返回已分配块的正整数标识符x(x初始值为0，每次分配增长1)\n\nerase x —— 删除标识符x所在的块\n\ndefragment —— 整理空余内存碎片，将所有块尽量靠近内存的开始位置，并保持各自的顺序\n\n在此情况下，内存模型非常简单，它是一个m字节的序列，为了方便起见，从第一个字节到第m字节进行编号。\n\n第一个操作alloc n有一个参数n，表示被分配的内存块大小。在处理此操作时，内存中将分配n个连续字节的空闲块。 如果这些块的数量超过一个，则优先选择最接近内存开始(即第一个字节)的块。 所有这些字节都被标记为非空闲，内存管理器返回一个32位整数数字令牌，代表该块的标识符。 如果不可能分配这样大小的空闲块，则返回NULL。\n\n第二个操作erase x以x为参数，表示某个块的标识符。此操作释放系统内存，将此块的字节标记为空闲以供进一步使用。 如果此标识符没有指向先前分配的块(该块尚未被释放)，则返回ILLEGAL_ERASE_ARGUMENT。\n\n最后一个操作defragment没有任何参数，只会使占用的内存部分更接近内存的开始，而不会更改它们各自的顺序。 \n\n在当前的实现中，将使用从1开始的连续整数作为标识符。每个成功的alloc操作过程都应该返回接下来的编号。不成功的alloc操作不影响计数。 \n\n编写内存管理器的实现，为每个alloc命令输出返回的值，为所有失败的erase命令输出ILLEGAL_ERASE_ARGUMENT。 \n\n【输入形式】\n\n输入数据的第一行包含两个正整数t和m（1<=t<=500, 1<=m<=105)，其中t表示需要内存管理器来处理的操作个数，m表示有效的内存字节大小。接下来的t行每一行代表一个操作。\n\n【输出形式】\n\n输出有多行，每行或者是alloc操作的结果，或者是失败的erase操作的结果ILLEGAL_ERASE_ARGUMENT。其顺序与输入的操作次序一致。\n\n【样例输入】\n\n```\n6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6\n```\n\n【样例输出】\n\n```\n1\n2\nNULL\n3\n```\n\n### 题解部分\n\n【思路】\n\n> 稍后补充\n\n【Accepted 代码】\n\nC++ 17\n\n```cpp\n// t01p12\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t = 0, m = 0;\n    cin >> t >> m;\n    int *a = new int[m];\n    for (int i = 0; i < m; ++i) {\n        a[i] = 0;\n    }\n    int x = 1;\n    while (t--) {\n        string str;\n        int n;\n        cin >> str;\n        if (str != \"defragment\") {\n            cin >> n;\n        }\n        int flag = 0;\n        if (str == \"alloc\") {\n            int left;\n            int right;\n            for (int j = 0; j < m; ++j) {\n                if (a[j] == 0) {\n                    left = j;\n                    while (a[j] == 0) {\n                        j++;\n                        if (j == m) {\n                            break;\n                        }\n                    }\n                    right = j;\n                    int len = right - left;\n                    if (len >= n) {\n                        flag = 1;\n                        for (int i1 = left; i1 < left + n; i1++) {\n                            a[i1] = x;\n                        }\n                        break;\n                    }\n                }\n            }\n            if (flag == 1) {\n                cout << x << endl;\n                x++;\n            } else {\n                cout << \"NULL\" << endl;\n            }\n        } else if (str == \"erase\") {\n            int key = n;\n            for (int i = 0; i < m; ++i) {\n                if (a[i] == key) {\n                    flag = 1;\n                    a[i] = 0;\n                }\n            }\n            if (flag == 0) {\n                cout << \"ILLEGAL_ERASE_ARGUMENT\" << endl;\n            }\n        } else if (str == \"defragment\") {\n            int *temp = new int[m];\n            for (int i1 = 0; i1 < m; ++i1) {\n                temp[i1] = 0;\n            }\n            int k = 0;\n            for (int i = 0; i < m; ++i) {\n                if (a[i] != 0) {\n                    temp[k] = a[i];\n                    k++;\n                }\n            }\n            for (int i2 = 0; i2 < m; ++i2) {\n                a[i2] = temp[i2];\n            }\n        }\n    }\n    delete[] a;\n    return 0;\n}\n```\n\n【遇到的问题】\n\n> 问题很多，稍后慢慢填坑\n\n## 本文许可协议\n\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.\n","tags":["开发与应用"]},{"title":"当我卸载了 oh-my-zsh 之后","url":"/2022/04/24/2022-04-24-一些zsh的配置/","content":"\n# 当我卸载了 oh-my-zsh 之后\n\n## 事件起因\n\n事情的起因是这样的，很久很久以前，我开始使用 zsh 的时候，根据「大部分」人推荐的方案，使用 oh-my-zsh 来对我的终端模拟器进行个性化的配置和设置。但是随着时间的推移，久而久之我就发现一个比较大的问题——自从安装使用了 oh-my-zsh 之后，我的 iTerm 启动速度肉眼可见的变慢了，而且有时候还无法正常加载配置。\n\n根据某位同学所言：「卸载了 oh-my-zsh 之后，zsh 的速度快了许多。」\n\n于是，我决定卸载 oh-my-zsh 了。\n\n当我卸载了 oh-my-zsh 之后，zsh 启动变快了不少。\n\n## oh-my-zsh 卸载方法\n\n在终端输入下面的命令，即可卸载 oh-my-zsh。但是需要注意的是，你很可能接下来不得不自己配置 zsh。\n\n```shell\nuninstall_oh_my_zsh\n```\n\n## 自行配置 zsh\n\n### 前期准备\n\n在 `home` 目录里找到一个 `.zshrc` 的文件，使用你喜欢的文本编辑器打开它。如果没有，创建一个。\n\n使用下面的命令可以在不重新登录的情况下生效修改的配置。\n\n```shell\nsource ~/.zshrc\n```\n\n本文默认您已经安装了 Homebrew 或者 Linuxbrew。如果您不知道这是什么，[点击查看](https://brew.sh)。\n\n### 自定义 zsh 的提示符\n\n首先需要保证提示符在启动时加载，在 `.zshrc` 文件里写入下面内容。\n\n```shell\n# 加载提示符\nautoload -U promptinit\n```\n\n随后，可以根据自己的需要和喜好来自定义提示符。比如我是这样定义的，让提示符的前面显示一个小的 Apple™️ 标志。根据 zsh 可以设置右侧提示符，我将它设置为显示系统当前时间。\n\n```shell\n# 提示符颜色\nautoload -U colors && colors\nPROMPT=\"%{$fg[magenta]%}%n%{$reset_color%}@%{$fg[magenta]%}%m %{$fg[cyan]%}%1~ %{$reset_color%}%# \"\nRPROMPT=\"[%{$fg[magenta]%}%*%{$reset_color%}]\"\n```\n\n下面提供提示符的一些转义变量。\n\n| 转义变量 | 描述 |\n| --- | --- |\n| `%T` | 系统时间（时:分） |\n| `%*` | 系统时间（时:分:秒） |\n| `%D` | 系统日期（年-月-日） |\n| `%n` | 你的用户名 |\n| `%B - %b` | 从开始到结束使用粗体打印 |\n| `%U - %u` | 从开始到结束使用下划线打印 |\n| `%d` | 你当前的工作目录 |\n| `%~` | 你当前的工作目录相对于 `~` 的路径，`~` 前面带数字可以设定最多显示几层目录（有些版本的 zsh 可能会乱码） |\n| `%M` | 计算机的主机名 |\n| `%m` | 计算机的主机名，在第一个句点之前截断 |\n| `%l` | 你当前的 tty |\n\n然后加点颜色，根据你的习惯搭配，提高辨识度，降低出错率。把配置放在 `%{ [...] %}` 里面确保光标不移动。\n\n| 命令 | 描述 |\n| --- | --- |\n| `$fg[color]` | 设置文本的颜色 |\n| `%F{color} [...] %f` | 和前面介绍的 `$fg` 是一样的，但是更简洁。还可以在 `F` 前面添加数字 |\n| `$fg_no_bold[color]` | 设置文本为非粗体同时设定文本颜色 |\n| `$fg_bold[color]` | 设置文本为粗体同时设定文本颜色 |\n| `$reset_color` | 重置文本颜色（改为默认颜色）,不会重置粗体设定,使用 `%b` 来重置粗体设定,可以使用 `%f` 来简化配置 |\n| `%K{color} [...] %k` | 设置背景颜色,和非粗体文本颜色一样,任何单一数字前缀会设置背景为黑色 |\n\n可以选择的颜色值，列在下方表格中。\n\n| 颜色 | 英文表示 | 数字表示 | 颜色 | 英文表示 | 数字表示 |\n| --- | --- | --- | --- | --- | --- |\n| 黑色 | `black` | `0` | 蓝色 | `blue` | `4` |\n| 红色 | `red` | `1` | 紫色 | `magenta` | `5` |\n| 绿色 | `green` | `2` | 青色 | `cyan` | `6` |\n| 黄色 | `yellow` | `3` | 白色 | `white` | `7` |\n\n### 文件目录的颜色\n\n为了让使用 `ls` 的命令时显示文件目录的不同类型文件有不同的颜色表示，我开启了 `ls` 命令的颜色显示，并根据使用习惯把颜色设定为 Linux 的默认配置。\n\n```shell\n# 文件目录颜色\nexport CLICOLOR=\"Yes\"\nexport LSCOLORS=\"ExGxFxdaCxDaDahbadacec\"\n```\n\n`LSCOLORS` 字串中的字母两个为一组，表示对应文件的颜色和显示方式。一共 22 个字母，定义了 11 种文件类型。文件类型的顺序依次列出如下。\n\n| 序号 | 类型说明 |\n| --- | --- |\n| 1 | 目录 |\n| 2 | 链接 |\n| 3 | socket 文件 |\n| 4 | 管道文件 |\n| 5 | 可执行文件 |\n| 6 | 块设备文件 |\n| 7 | 字块设备文件 |\n| 8 | 设定了 suid 的可执行文件 |\n| 9 | 设定了 guid 的可执行文件 |\n| 10 | 拥有 sticky 位的目录，组外用户拥有写权限 |\n| 11 | 没有 sticky 位的目录，组外用户拥有写权限 |\n\n相应地，颜色的配色方案也列表如下，可以自由搭配，两个一组，格式为：`前景色背景色`，连续写。\n\n| 小写字母 | 颜色解释 | 大写字母 | 颜色解释 |\n| --- | --- | --- | --- |\n| `a` | 黑色 | `A` | 黑色粗体 |\n| `b` | 红色 | `B` | 红色粗体 |\n| `c` | 绿色 | `C` | 绿色粗体 |\n| `d` | 棕色 | `D` | 棕色粗体 |\n| `e` | 蓝色 | `E` | 蓝色粗体 |\n| `f` | 洋红色 | `F` | 洋红色粗体 |\n| `g` | 青色 | `G` | 青色粗体 |\n| `h` | 浅灰色 | `H` | 浅灰色粗体 |\n| `x` | 系统默认颜色 |  |  |\n\n### zsh 的自动补全\n\n开启 zsh 自己的命令补全。\n\n```shell\n# 命令补全\nautoload -U compinit\n```\n\n### zsh 的代码高亮和自动补全提示以及其他插件\n\n```shell\n# 实用插件\nplugins=(git zsh-syntax-highlighting zsh-autosuggestions)\nsource /opt/homebrew/Cellar/zsh-syntax-highlighting/0.7.1/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nsource /opt/homebrew/Cellar/zsh-autosuggestions/0.7.0/share/zsh-autosuggestions/zsh-autosuggestions.zsh\n```\n\n把插件的名称放在 `plugins=(...)` 的括号中，注意插件与插件之间使用空格分开。插件可以使用 `source <dir>` 命令引入，`source` 后面跟着插件安装的位置目录。\n\n### 环境变量和路径\n\n这个根据自己的开发需要进行修改和配置，例如 Python 的解释器路径、Java 的环境变量、 Go 的 GOPATH 等等，如果不需要进行修改则可以忽略。这里不详细解释。\n\n```shell\n# Python 环境变量和路径\nexport PATH=\"/opt/homebrew/opt/python@3.10/bin:$PATH\"\n\n# Java 路径\nexport JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk-18.0.1.jdk\"\n\n# Go 路径\nexport GOPATH=\"$HOME/CodingSpace/go\"\n\n# Ruby 路径\nexport PATH=\"/opt/homebrew/Cellar/ruby/3.1.0/bin:$PATH\"\n```\n\n## 我的 zsh 配置分享\n\n可以拿去用，自行根据需要修改。可能有些字符不能显示。\n\n```shell\n# 加载提示符\nautoload -U promptinit\n\n# 提示符颜色\nautoload -U colors && colors\nPROMPT=\"%{$fg[magenta]%}%n%{$reset_color%}@%{$fg[magenta]%}%m %{$fg[cyan]%}%1~ %{$reset_color%}%# \"\nRPROMPT=\"[%{$fg[magenta]%}%*%{$reset_color%}]\"\n\n# 文件目录颜色\nexport CLICOLOR=\"Yes\"\nexport LSCOLORS=\"ExGxFxdaCxDaDahbadacec\"\n\n# 命令补全\nautoload -U compinit\n\n# 实用插件\nplugins=(git zsh-syntax-highlighting zsh-autosuggestions)\nsource /opt/homebrew/Cellar/zsh-syntax-highlighting/0.7.1/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nsource /opt/homebrew/Cellar/zsh-autosuggestions/0.7.0/share/zsh-autosuggestions/zsh-autosuggestions.zsh\n\n# Java 路径\nexport JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk-18.0.1.jdk\"\n\n# Ruby 路径\nexport PATH=\"/opt/homebrew/opt/ruby/bin:$PATH\"\n\n```\n\n## 想法及总结\n\n> 你不需要花哨的提示符。\n> ——摘自 [Zhihu](https://zhuanlan.zhihu.com/p/51008087)\n\nzsh 的界面是给我们提供方便的。如果它严重影响到了终端的性能和效率，比如 oh-my-zsh，启动和加载都要几秒甚至更长（在一些性能较差的计算机上），我完全没有理由去使用它，因为它已经背离我做 shell 美化的初衷了。\n\n我为什么要花大力气去自己配置 zsh 之类的设置？完全是为了自己平时用的顺手，如果您平时不使用 Terminal 和 shell，请当我没有说。\n\n除此之外，我发现在「简体中文网络」上搜索 zsh 的配置方案，结果有 99% 都是使用 oh-my-zsh 进行辅助配置。在这一点上，我认为 oh-my-zsh 是非常成功的，但是，根据我的日常使用情况来看，它的效率和性能实在是不敢恭维，显然没有自己写 `.zshrc` 配置来的高效。\n\n由此，我自己重新配置了 `.zshrc` 文件，并写下这些文字记录，以供参考。\n\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png\" /></a><br />This work is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.\n","tags":["Mac","开发与应用"]},{"title":"macOS Basic Usages","url":"/2022/01/26/2022-01-26-macOS使用基础/","content":"\n# macOS Basic Usages\n\n## 0. Introduction to macOS\n\nObviously, an operating system for Apple Mac computers.\n\n## 1. Restore Launchpad and Dock\n\n### 1.1 Restore Launchpad\n\nFirst, type the following command in Terminal.\n\n```shell\nrm ~/Library/Application\\ Support/Dock/*.db && killall Dock\n```\n\nThen, use this command to restore icons.\n\n```shell\ndefaults write com.apple.dock ResetLaunchPad -bool true && killall Dock\n```\n\nAfter doing the above steps, all the Apps made by Apple will be put into the first screen.\n\n### 1.2 Restore Dock\n\nFirst, type the following in Terminal.\n\n```shell\ndefaults delete com.apple.dock\n```\n\nThen, use the following command to restart the Dock.\n\n```shell\nkillall Dock\n```\n\nAll is done.\n\n## 2. Install Softwares\n\n### 2.1 macOS Software Packages\n\nGenerally, macOS software packages are with names end with `.app`, which make them look like files. Actually, an App package is a folder named with `AppName.app`, containing all the components for the program. If you want to see the contents, just secondary click the App icon, choose `Show Package Contents` option. Remember that double click the icon will only open and run the software.\n\n### 2.2 Install an App\n\n#### 2.2.1 Install an App from App Store\n\n1. Open App Store, login with your Apple ID\n2. Search your App on the left.\n3. Or you can choose the classified gallery.\n4. Or have a glance at the Discovery pages.\n\n#### 2.2.2 Get an PKG File?\n\nUse Installer to install the app if you have a `xxx.pkg` file.\n\n1. Double click to open it.\n2. Follow the tips to install.\n\n#### 2.2.3 Get a DMG File?\n\nDrag and drop. If you have a `xxx.dmg` file, just open it.\n\n1. Drag the `xxx.app` icon to the `Applications` folder.\n2. Close the window and eject the image.\n\n#### 2.2.4 Get an Install.app?\n\nSome DMG files only contain an `xxxInstaller.app` package. Just run it and follow the steps.\n\nSome large softwares may use this installing methods.\n\nEject the image after the installation is done.\n\n#### 2.2.5 Get a ZIP File?\n\nUse a archiver to extract the file. Generally you will get a `xxx.app` package.\n\nMove the package into `Applications` folder.\n\n### 2.3 Want to use pirate Apps?\n\nNo, you don't want to.\n\n## 3. Recommended Apps\n\n### 3.1 Utilities\n\n#### VLC media player\n\nA cross-platform media player. Free and open-source.\n\nPortal: <https://www.videolan.org>\n\n#### Keka\n\nA free achiever with no ads.\n\nPortal: <https://www.keka.io>\n\n#### Motrix\n\nA Bittorrent downloading client. Free and open-source.\n\nPortal: <https://www.motrix.app>\n\n#### Downie\n\nVideo downloading. Not free.\n\n### 3.2 Developing Tools\n\n#### iTerm\n\nmacOS Terminal. Many functions.\n\n#### Clash\n\nA proxy tool.\n\n#### Visual Studio Code\n\nEditing envolved.\n\n#### UTM\n\nVirtual machines. Support Apple Silicon.\n\n### 3.3 Creative Apps\n\n#### Blender\n\nOpen-source 3D and editing app.\n\n#### Aegisub\n\nSubtitle editing app.\n\n\n","tags":["Mac"]},{"title":"Fortran Programming","url":"/2022/01/26/2022-01-26-FortranProgramming/","content":"\n# Fortran Programming Review\n\nMade by Rain Chen\n\nDec. 2021\n\n## 0. Fortran 简介\n\nFortran 是 Formula Translation 的缩写，是世界上最早推广使用的高级程序设计语言，主要适用于科学和工程问题的数值计算。\n\nFortran 90 增加了一些新特性。比如，自由格式源代码的输入，小写的 Fortran 关键字等等，还有改善的函数传参机制等。\n\n## 1. Fortran 95 程序设计初步\n\n### 1.1 程序的结构说明\n\n类型说明语句，输入语句，赋值语句，输出语句……\n\n```fortran\nprogram example\n    real a, b, c, d, x1, x2\n    read * , a, b, c\n    d = b * b - 4 * a * c\n    if (d >= 0) then\n        x1 = (-b + sqrt(d)) / (2 * a)\n        x2 = (-b - sqrt(d)) / (2 * a)\n        print * , \"x1 =\", x1\n        print * , \"x2 =\", x2\n    else\n        print * , \"方程无实根.\"\n    end if\nend program\n```\n\n在 Fortran 中使用 `!` 来表示注释。注释非常重要，没有注释的程序不能算合格的程序。\n\n一个 Fortran 程序由一个或者若干个程序单元组成，包括主程序单元，外部子程序单元，模块单元，数据块单元。一个程序中必须有且只有一个主程序单元。每一个程序单元以 `end` 结束。\n\n### 1.2 字符集\n\nFortran 95 的字符集，是在编写 Fortran 95 程序的时候能够使用的全部字符及符号的集合。包括：\n\n- 英文字母 a ~ z, A ~ Z\n- 阿拉伯数字 0 1 2 3 4 5 6 7 8 9\n- 22 个特殊字符\n\n除了字符型常量之外， Fortran 95 源程序不区分大小写。Fortran 95 字符集之外的可打印字符只能出现在注释、字符常量、字符串编辑符和输入输出记录中。\n\n### 1.3 标识符\n\n标识符是名称。用来在程序中标识有关实体，比如变量、符号常量、函数、程序单元、公用块、数组、模块和形参等。规定标识符只能由字母、数字、下划线和美元符号组成。\n\n### 1.4 关键字\n\nFortran 95 中的一种特定的字符串。正确的关键字在代码编辑器中会显示代码高亮。关键字有特定的含义，不能随便改变以防出现语法错误。需要注意的是，Fortran 95 对关键字不予以保留，关键字可以作为其他实体的名称，但是不建议这样做。使用关键字作为实体的名称会导致程序难以理解和阅读。\n\n常用的 Fortran 95 关键字\n\n| 关键字 | 关键字 | 关键字 | 关键字 | 关键字 |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n| `program` | `implicit` | `read` | `write` | `print` |\n| `format` | `call` | `real` | `integer` | `character` |\n| `do` | `end` | `if` | `parameter` | `complex` |\n| `logical` | `double precision` | `then` | `open` | `subroutine` |\n| ... | ... | ... | ... | ... |\n\n### 1.5 书写格式\n\n#### 1.5.1 固定格式 Fixed Format\n\n每行 80 个字符。分成 4 个区。\n\n##### 1.5.1.1 标号区\n\n- 1 到 5 列为标号区，标号最多为 5 位数字。\n- 数字中的空格不起作用\n- 标号区的第一个字符为 `!` 说明该行为注释行。\n\n##### 1.5.1.2 续行区\n\n- 第 6 列是续行区。续行标志为除去空格和零意外的任何 Fortran 字符。\n- 注释行没有续行的概念。\n\n##### 1.5.1.3 语句区\n\n- 第 7 到 72 列为语句区\n- 语句只能书写到语句区\n- 一行只能写一个语句，写不下可以分多个语句写，或者续行\n\n##### 1.5.1.4 注释区\n\n- 注释区中的注释不需要给出注释行的标志符。\n\n#### 1.5.2 自由格式 Free Format\n\n语句可以从任意位置开始书写。不受分区和位置限制。每一行可以编写 132 个字符。一行可以写多个语句，语句之间用语句分隔标志符 `;` 做间隔。续行标志符 `&` 出现在前一行的末尾。使用 `!` 作为注释符号。\n\n续行时要注意的问题：\n\n```fortran\ny = cos(atan(sqrt(x ** 3 + y ** 3) / (x ** 2 + 1))) + cos(x * y / (sqrt(x ** 2 + y ** 2))) + &\nexp(a * x ** 2 + b * x + c)\n```\n\n在没有把具有特定意义的字符分成两行的时候，只需在前面一行的末尾加上一个换行符 `&`，但是在把有特定意义的字符分成两行的时候，行尾要加一个换行符，下一行的开头也要加一个换行符。\n\n```fortran\ny = cos(atan(sqrt(x ** 3 + y ** 3) / (x ** 2 + 1))) + co&\n&s(x * y / (sqrt(x ** 2 + y ** 2))) + &\nexp(a * x ** 2 + b * x + c)\n```\n\n## 2. 数据类型\n\n### 2.1 基本数据类型\n\n#### 2.1.1 数值型\n\n##### 2.1.1.1 整数类型 Integer\n\n- 长整型\n- 短整型\n\n整数数据类型包括正数、负数和 0。\n\n| 整数类型名 | 字节数 | 取值范围                                    |\n| --- | --- |-----------------------------------------|\n| INTEGER(1) | 1 | $ - 2 ^ 7 $ ~ $ 2 ^ 7 - 1 $             |\n| 短整型 INTEGER(2) | 2 | $ - 2 ^ {15} $ ~ $ 2 ^ {15} - 1 $       |\n| 长整型 INTEGER | 4 | $ -2 ^ {31} $ ~ $2 ^ {31} - 1 $         |\n| INTEGER(8) | 8 | $ - 2 ^ {63} $ ~ $ 2 ^ {63} - 1 $ （Alpha 系统） |\n\n##### 2.1.1.2 实数类型 Real\n\n又称为浮点数。数值是近似值，有误差累计。通常有两种表示形式，十进制的小数形式和指数形式。\n\n> 注意：指数形式表示时，指数部分必须是整数。\n\n| 实数类型名 | 字节数 | 精度（有效数字） | 取值范围 |\n| --- | --- | --- | --- |\n| 单精度 | 4 | 6 ~ 7 | $ \\pm 3.40282347E38 $ ~ $ \\pm 1.17549435E-38 $ |\n| 双精度 | 8 | 16 ~ 17 | $ \\pm 2.2250738585072013D308 $ ~ $ \\pm 1.7976931348623158D-08 $ |\n\n##### 2.1.1.3 复数类型 Complex\n\n单精度复数和双精度复数。表示形式：\n\n```fortran\n(a, b)\n```\n\n例如：`(1.2, 3.5)` 表示 $ 1.2 + 3.5i $ 。\n\n> Fortran 是目前唯一提供复数类型的计算机语言。\n\n#### 2.1.2 非数值型\n\n##### 2.1.2.1 字符类型 Character\n\n只有一个字母或符号称为字符，有多个字符时称为字符串。使用一对单引号或者一堆双引号括起来，例如：\n\n```fortran\n'Fortran charater'    ! 用单引号\n\"hello world!\"    ! 用双引号\n```\n\n##### 2.1.2.2 逻辑类型 Logical\n\n表示判断的结果，只有两种值：是和否，即对错，真假。\n```fortran\n.true.    ! 真\n.false.    ! 假\n```\n\n### 2.2 数组类型\n\n数组是类型相同的一批数据的有序集合。每个数组有一个数组名。\n\n#### 2.2.1 定义数组\n\n##### 2.2.1.1 用 dimension 语句定义数组\n\n```fortran\ndimension 数组名(下标下界 : 下标上界, ...), ...\n```\n\n数组说明符定义了数组名、数组的维数和大小。数组的维数由维数说明符的个数确定。维数说明符最少有 1 个，最多有 7 个。数组的大小就是数组元素的个数。\n\n例如：\n\n```fortran\ndimension g(10), s(3, 5)\ndimension g(1 : 10), s(1 : 3, 1 : 5)    ! 含义相同\n```\n\n在 dimension 语句之后可以使用类型说明语句说明数组的类型，不需要重复写维数说明符。\n\n```fortran\ndimension a(1 : 10), n(10 : 15), m(-1 : 1, 0 : 2, 0 : 3), name(1 : 30)\nreal a, n\ninteger b, m\ncharacter * 8 name\n```\n\n##### 2.2.1.2 用类型说明语句定义数组\n\n一般格式为：\n\n```fortran\n类型说明符 数组名(下标下界 : 下标上界, ...), ...\n```\n\n定义数组时必须明确数组的大小。\n\n##### 2.2.1.3 同时使用类型说明语句和 dimension 语句定义数组\n\n一般格式为：\n\n```fortran\n类型说明符, dimension(下标下界 : 下标上界, ...) :: 数组名[, ...]\n```\n\n例如：\n\n```fortran\ninteger, dimension(10) :: a, n, w(2, 3)\n```\n\n#### 2.2.2 给数组赋初值\n\n##### 2.2.2.1 使用数组赋值符赋值\n\n一般格式：\n\n```fortran\n数组名 = (/取值列表/)\n```\n\n取值列表可以是类型相同的常量、变量、函数、表达式或者隐含 do 循环，它们之间用逗号隔开。\n\n```fortran\nprogram array\n    integer a(5), b(5)\n    k = 1\n    a = (/1, 3, k + 4, 7, 9/)\n    b = (/i, i = 2, 10, 2/)\n    print * , a\n    print * , b\nend program\n```\n\n##### 2.2.2.2 使用 data 语句给数组赋初值\n\ndata 语句时专门用来给变量、数组、数组元素赋初值的语句。一般格式如下：\n\n```fortran\ndata 数组名/常量表/, 数组名/常量表/, ...\n```\n\n数组元素个数必须和常量一一对应。\n\n#### 2.2.3 对数组的操作\n\n##### 2.2.3.1 对元素的操作\n\n对数组进行操作要先定义再使用。对数组元素的操作即是对数组元素的引用。\n\n一般格式为：\n\n```fortran\n数组名(下标, [下标], ...)\n```\n\n例如：\n\n```fortran\ninteger a(2, 2), b(5)\na(1, 1) = 10    ! 对数组 a 中的第一个元素赋值为 10\ndo i = 1, 5\n    b(i) = 3\nend do\n```\n\n##### 2.2.3.2 对整体的操作\n\n用数组名代表整个数组。\n\n```fortran\ninteger a(2, 2), b(5)\na = 10\nb = 3\n```\n\n当数组 a 和数组 b 和数组 c 维数大小相同时，可以直接操作：\n\n```fortran\na = b    ! 把数组 b 中的同一位置的元素的值对应赋值给 a 数组中的对应元素\na = b + c\na = b - c\na = b * c\na = b / c\n```\n\n##### 2.2.3.3 局部引用\n\n例如：\n\n```fortran\ninteger a(6)\na(3 : 5) = 0    ! 把 a(3), a(4), a(5) 赋值为 0\na(1 : 6 : 2)  = 3    ! 把 a(1), a(3), a(5) 赋值为 3\n```\n\n数组元素的三元表达式可以写成：\n\n```fortran\n初值 : 终值 : 步长\n```\n\n可以通过三元表达式引用数组的一部分。例如：\n\n```fortran\nb(4, 6) = a(1, 3)\n```\n\n### 2.3 指针类型\n\n省略此部分内容。\n\n### 2.4 派生类型与结构体\n\n自己定义的数据类型。\n\n> Fortran 90 之前的版本不支持结构体\n\n#### 2.4.1 派生类型定义\n\n使用 type 块来定义一个派生类型，应该写在程序说明部分，通常是写在说明的前部。派生类型是一种抽象。\n\n定义格式：\n\n```fortran\ntype 派生类型名\n    member1 类型说明\n    member2 类型说明\n    member3 类型说明\n    member4 类型说明\n    ...\n    membern 类型说明\nend type [派生类型名]\n```\n\n#### 2.4.2 结构体的定义与引用\n\n结构体是对派生类型的一种具体化。只有定义了派生类型结构体或结构体数组，才能对结构体或结构体数组成员进行处理。\n\n结构体定义的一般格式如下：\n\n```fortran\ntype(派生类型名) :: 结构体列表\n```\n\n引用结构体成员需要这样写：\n\n```fortran\n结构体名 % 成员名\n结构体名.成员名    ! 这样也行，不过最好两种不要混用\n```\n\n在嵌套定义的结构体中，成员引用应该嵌套使用引用符 `%` 或者 `.`。例如：\n\n```fortran\nstu % date % year\n```\n\n使用 `.` 作为引用符，成员名不能使用逻辑运算符和关系运算符。\n\n### 2.5 公用区类型\n\n省略此部分内容。\n\n## 3. 变量与常量\n\n### 3.1 变量\n\n#### 3.1.1 变量的概念\n\n程序运行期间其值可以改变的量。变量是程序处理的主要对象。系统为程序中的每一个变量开辟一个存储单元，用来存放变量的值。\n\n> 在每一个瞬间，变量只能有一个确定的值。\n\n在程序中用到的变量，应该给它赋予确定的值，否则计算机系统就会给它一个不确定的随机值，也有些系统会把程序未赋值的变量的值设置为 0。\n\n#### 3.1.2 变量名\n\n一个变量需要用一个变量名来识别，变量名就是变量的名字。在同一个程序单元中，不能用同一个变量名来代表两个不同的变量。Fortran 的变量名只能由字母、数字、下划线和美元符号组成。\n\n- 在变量名中大小写字母是等价的。`SUM`、`Sum`、`sum`、`suM` 都代表同一个变量。\n- 变量名中的字符可以插入空格\n- 变量命名要可以做到顾名思义：使用一些有意义的单词对变量命名。\n- 虽然 Fortran 没有规定保留字，但是为了避免混淆，建议不要使用 Fortran 中的关键字作为变量名。\n\n#### 3.1.3 类型\n\n变量应该先说明后使用。声明变量的数据类型，以便分配相应大小的存储空间来存放值。\n\n##### 3.1.3.1 隐含约定：I-N 规则\n\nFortran 规定凡是以 `i, j, k, l, m, n` 开头的（不区分大小写）变量名，都认为该变量是整型变量。以其他字母开头的变量为实型变量。\n\n```fortran\ni, j, max, n1, num    ! 整型变量\na, b, c, x, y, sum, aver, count, total    ! 实型变量\n```\n\n##### 3.1.3.2 使用类型说明语句\n\n类型说明语句可以强制置顶某些变量的类型。\n\n```fortran\ninteger <变量>    ! 整型说明语句\nreal <变量>    ! 实型说明语句\ndouble precision <变量>    ! 双精度型说明语句\ncomplex <变量>    ! 复数说明语句\ncharacter <变量>    ! 字符型说明语句\nlogical <变量>    ! 逻辑型说明语句\n```\n\n在类型声明后使用 `::` 可以对变量进行初始化。\n\n```fortran\ninteger x, y, z    ! 定义 x, y, z 是整型变量\ncharacter * 30 name    ! 定义 name 是字符型变量，长度为 30\ncomplex :: s = (1.5, 8.9)    ! 定义 s 是单精度复数型变量，对它赋初值\ninteger(2) :: a = 1.8    ! 定义 a, b 是短整型变量，对变量 a 赋初值\nreal * 8 l    ! 定义 l 是双精度型变量\n```\n\n##### 3.1.3.3 使用 implicit 语句\n\n隐含说明语句。可以将某个字母开头的变量名指定为某个变量类型。\n\n取消隐含声明：\n\n```fortran\nimplicit none\n```\n\n更改一个隐含声明：\n\n```fortran\nimplicit integer(a, f, c, t - v)    ! 把 a, f, c, t 到 v 开头的变量指定为整数类型\n```\n\n可以使用一个 `implicit` 语句声明多种类型。例如：\n\n```fortran\nimplicit integer(a, b, x - z), real(i, k), character(c, n)\n```\n\n> 类型声明的优先级：类型说明语句最高，`implicit` 语句次之，I-N 规则最低。\n\n#### 3.1.4 给变量赋初值\n\n##### 3.1.4.1 直接赋值\n\n先定义一个变量，然后给它赋值。\n\n```fortran\ninteger a\na = 20\n```\n\n或者直接初始化。\n\n```fortran\ninteger :: a = 10\n```\n\n##### 3.1.4.2 用 data 语句给变量赋初值\n\n一般格式：\n\n```fortran\ndata var1, var2, ... , varn /c1, c2, ..., cn/\n```\n\n- 可以同时给多个变量赋初值，中间用逗号隔开。\n- 被赋值的常量放在一对 `//` 中间。\n- 被赋值的常量的数据类型与对应的变量的数据类型要一致。\n- 可以使用 `*` 来表示数据的重复。\n\n```fortran\ndata m, n, k /3 * 5/\n```\n\n执行上名语句之后，变量 `m`、`n`、`k` 的值都为 5。\n\n### 3.2 常量\n\n常量在程序中直接给出，在程序运行时保持不变。分为直接常量和符号常量。\n\n#### 3.2.1 直接常量\n\n包括：整型常量、实型常量、双精度型常量、复型常量、字符型常量和逻辑型常量。\n\n##### 3.2.1.1 整型常量\n\n可以表示成十进制以及二至三十六进位制。\n\n对于十进制的整数，通过整型 kind 值（类别类型参数）来确定整数的存储空间大小和取值范围。整型的 kind 值有四种：1，2，4（默认是 4 ），8（仅对 Alpha 系统有效）。\n\n表示方法：`number_kind`。例如：\n\n```fortran\n-16_2, 18_4, 5_1\n```\n\n对于二至三十六进位制，表示形式是：`r#number` 或 `-r#number`，通常来说，十六进制常省略基数 16。\n\n```fortran\nprint * , 2#1111001111001111001111\nprint * , 7#45644664\nprint * , +8#17171717\nprint * , 3994575\nprint * , #3cfecf\nprint * , 36#2dm8f\n```\n\n##### 3.2.1.2 实型常量和双精度型\n\n通常表示成十进制小数和指数两种形式。必须包含小数点。\n\n小数形式：\n\n```fortran\nn.m\nn.\n.m\n```\n\n指数形式：\n\n```fortran\nn.mEs\nn.Es\nnEs\n.mEs\n```\n\n##### 3.2.1.3 复型常量\n\n采用坐标的形式表示一个复数。可以时确定的数，也可以是一个有确定结果的表达式。\n\n##### 3.2.1.4 字符型常量\n\n就是字符串，使用单引号或者双引号括起来的若干字符序列。\n\n非打印字符表示形式\n\n| 表示形式 | 非打印字符 | 表示形式 | 非打印字符 |\n| --- | --- | --- | --- |\n| `\\a` 或 `\\A` | BELL | `\\v` 或 `\\V` | 垂直 Tab |\n| `\\b` 或 `\\B` | 退格 | `\\t` 或 `\\T` | 水平 Tab |\n| `\\f` 或 `\\F` | 进格 | `\\\\` | 输出 `\\` |\n| `\\n` 或 `\\N` | 换行 | `\\xhh` | 输出十六进制编码为 hh 的任意 ASCII 字符 |\n| `\\r` 或 `\\R` | 回车 | `\\ddd` | 输出八进制编码为 ddd 的任意 ASCII 字符 |\n\n##### 3.2.1.5 逻辑型常量\n\n只有两个：`.true.` 和 `.false.`。注意，逻辑值两边的小数点必须有，不区分大小写。逻辑型 kind 值有 4 中，分别是 1，2，4，8（仅对 Alpha 系统有效）。对于逻辑值 `.true.`，在其存储单元内每个二进制位上都是 1，可以视为整数 -1；对于逻辑值 `.false.`，其存储单元内每个二进制位上都是 0，可以视为整数 0。\n\n> 逻辑值可以参与数值型数据的运算。\n\n#### 3.2.2 符号常量\n\n是一种特殊的常量，程序单元内代表常量的标识符。\n\n```fortran\nparameter(标识符 = 常量, 标识符 = 常量, ...)\n```\n\n## 4. 表达式\n\nFortran 中一共四种表达式：\n\n- 算术表达式\n- 字符表达式\n- 关系表达式\n- 逻辑表达式\n\n### 4.1 算术表达式\n\n顾名思义，加减乘除。\n\n### 4.2 字符表达式\n\n字符连接符 `//` 把两个字符型数据连接起来，组成一个新的字符型数据。\n\n```fortran\ncharacter * 5 ch1, ch2, ch3, ch4 8 1, ch5 * 11\nch1 = \"LOVE\"\nch2 = \"CHINA\"\nch3 = \"STUDENT\"\nch4 = \"I\"\nch5 = ch4 // \" \" // ch1 // \"YOU!\"\n```\n\n### 4.3 关系表达式\n\nFortran 提供了 6 个关系运算符。两种格式可以单独使用，也可以混合使用。使用字母格式时两边的点不能省略。各关系运算符优先级别相同，从前向后一次运算即可。\n\n| 字母格式 | 符号格式 | 英语含义 | 数学含义 |\n| --- | --- | --- | --- |\n| `.lt.` | `<` | less than | 小于 |\n| `.le.` | `<=` | less than or equal to | 小于等于 |\n| `.eq.` | `==` | equal to | 等于 |\n| `.ne.` | `/=` | not equal to | 不等于 |\n| `.gt.` | `>` | greater than | 大于 |\n| `.ge.` | `>=` | greater than or equal to | 大于等于 |\n\n一般表达式：\n\n```fortran\n<算术量1> 关系运算符 <算术量2>\n```\n\n> 谨慎使用等于或不等于关系判断实型。实型数据是使用近似值存储的，可能存在误差。\n\n### 4.4 逻辑表达式\n\nFortran 提供了 6 种逻辑运算符。\n\n| 逻辑运算符 | 名称 | 运算举例 |\n| --- | --- | --- |\n| `.and.` | 逻辑与 | `a .and. b` |\n| `.or.` | 逻辑或 | `a .or. b` |\n| `.not.` | 逻辑非 | `not. a` |\n| `.eqv.` | 逻辑等 | `a .eqv. b` |\n| `.neqv.` | 逻辑不等 | `a .neqv. b` |\n| `.xor.` | 逻辑运算 | `a .xor. b` |\n\n一般表达式：\n\n```fortran\n<逻辑量1> 逻辑运算符 <逻辑量2>\n```\n\n## 5. 程序的结构\n\n### 5.1 顺序结构\n\n顺序结构只能从上到下依次执行一条语句。很常见。\n\n#### 5.1.1 赋值语句\n\n赋值语句用于赋值。一般格式就是：\n\n```fortran\nV = e    ! Variable = expression\n```\n\n仔细理解，没有别的了。\n\n#### 5.1.2 输出语句\n\n- 按系统隐含的标准格式输出：自由格式输出，又叫表控输出。\n- 按用户指定格式输出：有格式输出。例如：`100 format(...)`\n- 无格式输出：以二进制形式输出数据，只适用于向磁盘等输出，对文件进行操作。\n\n##### 5.1.2.1 表控输出语句\n\n```fortran\nprint * , 输出列表项\n```\n\n`*` 表示在系统隐含指定输出设备（一般是显示器）上按系统隐含的标准格式输出数据。如果 `*` 后没有任何输出项，相当于一个换行。\n\n或者可以写成：\n\n```fortran\nwrite(*, *) 输出列表项\n```\n\n第一个 `*` 表示系统隐含指定的输出设备，第二个 `*` 表示用表控格式输出。\n\n##### 5.1.2.2 其他输出\n\n省略此部分内容。\n\n#### 5.1.3 输入语句\n\n##### 5.1.3.1 表控输入语句\n\n```fortran\nread * , 输入项列表\n```\n\n`*` 表示从系统隐含指定的输入设备（一般是键盘）按表控格式输入数据。例如：\n\n```fortran\nread * , a, b, c\n```\n\n也可以写成这样：\n\n```fortran\nread(* , *) 输入表\n```\n\n其中第一个 `*` 表示系统隐含的指定输入设备（键盘），第二个 `*` 表示表控输入。\n\n##### 5.1.3.2 其他输入\n\n省略此部分内容。\n\n#### 5.1.4 end、stop、pause 语句\n\n##### 5.1.4.1 end 语句\n\n结束语句。\n\n- 结束本程序单元的运行\n- 作为一个程序单元的结束标志，写在所在程序单元的最后一行\n\nend 语句在主程序中兼有 `stop` 语句的作用，使程序停止运行，在子程序中兼有 `return` 语句的功能，控制返回到调用程序。\n\n##### 5.1.4.2 stop 语句\n\n一般格式：\n\n```fortran\nstop [n]\n```\n\n其中 `n` 是一个不超过五位数的数字或者一个字符串。执行 `stop` 语句的时候输出整数或者字符串，供程序员辨别程序流程。\n\n> 除非必要，不要把 `stop` 命令放在主程序结束之外的其他地方，因为如果一个程序有太多的结束终点，容易出错。`stop` 命令不是必要的，因为程序执行完毕之后会自动停止。\n\n##### 5.1.4.3 pause 语句（弃用）\n\n让系统把程序暂时挂起，等待程序员完成其他工作。可以理解为一个断点（breakpoint），便于调试程序。\n\n一般格式：\n\n```fortran\npause [n]\n```\n\n> 由于现在的编译环境中可以直接设置断点，所以 `pause` 语句一般不再使用。如果使用，可能会出现警告。\n\n### 5.2 选择结构\n\n#### 5.2.1 逻辑 if 语句\n\n```fortran\nif (表达式e) 可执行语句s\n```\n\n表达式可以是逻辑表达式或者关系表达式。\n\n#### 5.2.2 块 if 语句\n\n##### 5.2.2.1 单分支\n\n```fortran\nif (表达式e) then\n    <then 块>\nend if\n```\n\n##### 5.2.2.2 双分支\n\n```fortran\nif (表达式e) then\n    <then 块>\nelse\n    <then 块>\nend if\n```\n\n##### 5.2.2.3 多分支\n\n```fortran\nif (表达式e1) then\n    <then 块1>\nelse if (表达式e2) then\n    <then 块2>\n    ...\nelse if (表达式en) then\n    <then 块n>\nend if\n```\n\n#### 5.2.3 块 case 结构\n\n多重判断除了使用 if 结构完成之外，还可以使用 case 结构。\n\n```fortran\nselect case(表达式e)\ncase(数值1)\n    <块1>\ncase(数值2)\n    <块2>\n    ...\ncase(数值n)\n    <块n>\ncase default\n    <块n+1>\nend select\n```\n\n块 case 结构有限制。表达式 e 只能时整型、字符型或者逻辑型。每个 `case` 语句中所使用的数值必须是固定的常量，不能使用变量，类型要与表达式 e 的类型一致。\n\n#### 5.2.4 多重 if 结构嵌套\n\n注意内层和外层不能交叉，包含关系必须清楚。\n\n> 为了使程序清晰，应该使用缩进，同一层级对齐。\n\n### 5.3 循环结构\n\n#### 5.3.1 do 循环\n\n##### 5.3.1.1 一般 do 循环\n\n程序执行的重复次数已知时可用。\n\n```fortran\nprogram doloop\n    do i = 1, 10\n        print * , \"Hello\", i, \"次\"\n    end do\nend program\n```\n\n`do` 循环语句的一般格式写成：\n\n```fortran\ndo V = e1, e2[, e3]\n```\n\n中括号表示可以没有。`e1` 表示循环变量的初值，`e2` 表示循环变量的终值，`e3` 表示循环变量的步长（增量）。`V` 表示循环控制变量（计数器），即循环变量。\n\n循环变量在循环体中只能被引用，不能被赋值。\n\n举个「水仙花数」的例子：\n\n```fortran\nprogram flower\n    integer n, n1, n2, n3\n    do n = 100, 999\n        n1 = n / 100\n        n2 = mod(n / 10, 10)\n        n3 = mod(n, 10)\n        if (n1 ** 3 + n2 ** 3 + n3 ** 3 == n) then\n            print * , n, \"是水仙花数\"\n        end if\n    end do\nend program\n```\n\n##### 5.3.1.2 隐含 do 循环\n\n这样写：\n\n```fortran\nprint * , (W, V = e1, e2[, e3])    ! 输出\nread * , (W, V = e1, e2[, e3])    ! 输入\n```\n\n`W` 是输入或者输出项的列表。\n\n> 隐含 do 循环在一行中输出，而一般的 do 循环将换行输出。\n\n#### 5.3.2 do while 循环\n\n一般格式：\n\n```fortran\ndo while (逻辑表达式)\n    循环体\nend do\n```\n\n该循环由三部分组成，分别是 `do while` 语句、循环体和 `end do` 语句。\n\n> 在使用 do while 循环的时候，一定要避免死循环。保证循环中至少有一条控制循环条件的语句。\n\n#### 5.3.3 exit 语句\n\n顾名思义，跳出循环。do 循环和 do while 循环都可以使用 `exit` 语句。\n\n#### 5.3.4 cycle 语句\n\n略过循环体 `cycle` 语句之后的所有语句，直接跳回开头执行下一次循环。do 循环和 do while 循环都可以使用 `cycle` 语句。\n\n## 6. 函数与子程序\n\n循环不能消除不同程序单元之间的重复行为，为了解决这类问题，Fortran 设计语言产生了一种新技术：子程序。子程序是能结局某个特定问题的相对独立的程序单元。\n\n> 子程序不能单独运行，只能被调用。\n\n### 6.1 语句函数\n\n定义形式：\n\n```fortran\n函数名(x1, x2, x3, ..., xn) = 表达式\n```\n\n#### 6.1.1 语句函数名\n\n命名方法与变量命名方法相同。注意，语句函数名不能与本程序单元中的任何其他变量同名。例如：\n\n```fortran\nroot1(a, b, c) = (- b + sqrt(b ** 2 - 4.0 * a * c)) / (2.0 * a)\nda(a, b) = sqrt(b * b + a * a * a)\ninteger db\ndb(a, b) = sqrt(b * b + a * a)\n```\n\n#### 6.1.2 形式参数\n\n如果语句函数没有形式参数时，括号也不能省略。当形式参数多于一个时，它们之间用逗号隔开。形式参数不代表任何实在的值，因此，它可以与程序中的变量同名。\n\n#### 6.1.3 语句函数的调用\n\n一旦声明了语句函数，就可以在同一程序单元中调用它。一般写成：\n\n```fortran\n函数名(实参表)\n```\n\n### 6.2 函数子程序\n\n语句函数只能解决一些较为简单的问题，当函数关系较为复杂，用一个语句无法定义的时候就需要函数子程序。\n\n#### 6.2.1 函数子程序的定义\n\n```fortran\n[类型说明符] function 函数名(形式参数表)\n    函数体\nend [function [函数名]]\n```\n\n函数名的类型说明既可以放在函数名之前，也可以放在函数体的开头。\n\n#### 6.2.2 函数子程序的调用\n\n方法与调用标准函数、语句函数相同。这样写：\n\n```fortran\n函数名(实参列表)\n```\n\n### 6.3 子例行子程序\n\nSubroutine，子例行子程序。子例行子程序的名字不代表一个具体的值，与函数子程序不同，它只是提供调用时的一个识别符号，因此需要类型说明。\n\n#### 6.3.1 子例行子程序的定义\n\n```fortran\nsubroutine 子例行子程序名(形式参数表)\n    程序体\nend [subroutine [子例行子程序名]]\n```\n\n#### 6.3.2 子例行子程序的调用\n\n```fortran\ncall 子例行子程序名(实参表)\n```\n\n注意，当子例行子程序没有形式参数时，调用方式如下：\n\n```fortran\ncall 子例行子程序名\n```\n\n此时调用的子例行子程序名后面没有括号。\n\n### 6.4 递归子程序\n\n> Fortran 在 90 版本之前是不支持递归调用的。\n\n小心设计！递归调用容易造成死循环。递归函数的一般形式如下：\n\n```fortran\nrecursive function 函数名([形式参数表]) result(函数结果名)\n    调用该函数本身\nend [function [函数名]]\n```\n\n递归子程序的一般形式则是这样：\n\n```fortran\nrecursive subroutine 子程序名([形式参数表])\n    调用该子程序本身\nend [subroutine [子程序名]]\n```\n\n## 7. 文件\n\n### 7.1 文件的基本概念\n\nFile，就是一组相关信息的集合，给定一个标识符，并将其存放在计算机的某一个存储介质上。在对文件进行操作的时候是以记录为基本单位的。\n\n### 7.2 什么是记录\n\n- 有格式记录\n  - 是有序的格式化数据序列，每个记录以回车符作为结束标志\n- 无格式记录\n  - 由二进制代码直接传输，在输入输出是无需格式转换\n  - 传输速度较快，占用磁盘空间较小\n- 文件结束记录\n  - 是文件结束的标志，由操作系统来规定\n  - 不作为数据的内容来处理\n\n### 7.3 文件的特性\n\n#### 7.3.1 文件标识\n\n简单来说，就是文件所在的路径。计算机根据文件标识符来寻找文件。\n\n#### 7.3.2 文件的存取方式\n\n两种。\n\n- 顺序存取\n- 直接存取\n\n顺序文件的存取操作总是从第 1 个记录开始，然后依次按文件记录的逻辑顺序逐个往下进行。如果要操作第 n 个记录，那么就要先操作第 n - 1 个记录。\n\n直接文件的存取操作可以按任意的次序进行。可以直接按存取操作指定的记录号进行。\n\n#### 7.3.3 文件的结构\n\n有格式存放、无格式存放和二进制存放。除了第一种有格式存放使用 ASCII 字符存放之外，其余两种都使用二进制存放。\n\n#### 7.3.4 文件的定位\n\n文件指针。控制文件的读写操作。当文件指针位于第一个记录前的位置，称为「文件头」。当文件指针位于某一个记录中时，称该记录为「当前记录」。当文件指针位于最后一个记录后的位置时，称文件定位在「文件尾」。\n\n### 7.4 文件的操作语句\n\n#### 7.4.1 文件的打开和关闭\n\n文件的打开语句，这样：\n\n```fortran\nopen(unit = number, file = \"filename\", form = \"...\", status = \"...\", access = \"...\", recl = length,&\n    err = label, iostat = var, blank = \"...\", position = \"...\",&\n    action = action, pad = \"...\", delim = \"...\")\n```\n\n文件的关闭语句，这样：\n\n```fortran\nclose(unit = number, err = label, iostat = var, status = \"...\")\n```\n\n#### 7.4.2 文件的输入输出\n\n文件打开之后就可以进行读写操作了，也就是输入输出。输入语句格式如下：\n\n```fortran\nread(unit = number, fmt = format, nml = namelist, rec = record, iostat = stat,&\n    err = errlabel, end = endlabel, advance = advance, size = size)\n```\n\n文件的输出与文件输入的格式完全相同，只不过把 `read` 改为 `write` 而已。\n\n```fortran\nwrite(unit = number, fmt = format, nml = namelist, rec = record, iostat = stat,&\n    err = errlabel, end = endlabel, advance = advance, size = size)\n```\n\n## 8. Fortran 并行计算基础\n\n### 8.1 MPI 使用概述\n\nMPI 消息传递接口。多台机器同时计算时，一边计算一边传递信息。同一个程序，在每一个节点上运行一个进程。\n\n```fortran\ninclude 'mpif.h'\ninteger b, y, ierr, myid, num, status(mpi_status_size), j2\ncall mpi_init(ierr)\ncall mpi_comm_rank(mpi_comm_world, myid, ierr)\ncall mpi_comm_size(mpi_comm_world, num, ierr)\ncall mpi_bcast(dmbig, i, mpi_logical, 0, mpi_comm_world, ieer)\ncall mpi_barrier(mpi_comm_world, ieer)\ncall mpi_barrier(mpi_comm_world, ieer)\ncall mpi_recv(delta1, 1, mpi_double_precision, 1, 0, mpi_comm_world, status, ieer)\ncall mpi_send(delta, 1, mpi_double_precision, 0, 0, mpi_comm_world, ieer)\ncall mpi_finalize(ieer)\n```\n\nFortran90 以上支持并行计算，子程序。\n\n```fortran\ncall mpi_init(ierr)\n```\n\n初始化。\n\n```fortran\ncall mpi_barrier(mpi_comm_world, ieer)\n```\n\n等所有的节点都执行到这一句之后，接下来才继续执行。\n\n```fortran\ncall mpi_recv(delta1, 1, mpi_double_precision, 1, 0, mpi_comm_world, status, ieer)\ncall mpi_send(delta, 1, mpi_double_precision, 0, 0, mpi_comm_world, ieer)\n```\n\n向其他节点发送以及从其他节点接受消息，用于同步数据。\n\n### 8.2 编译含有 MPI 的并行计算程序\n\n编译，可以使用 GCC 或者 Intel 的编译器，建议使用 Intel 的 ifort。\n编译前需要使用命令方式配置编译环境。配置方法：在天河计算机上执行下面指令。\n\n```shell\nsource /opt/intel/Compiler/11.1/059/bin/intel64/iccvars_intel64.sh\nsource /opt/intel/Compiler/11.1/059/bin/intel64/ifortvars_intel64.sh\n```\n\n或者\n\n```shell\nsource /vol6/appsoftware/intel/11.1/059/bin/intel64/iccvars_intel64.sh\nsource /vol6/appsoftware/intel/11.1/059/bin/intel64/ifortvars_intel64.sh\n```\n\n把 Fortran90 源文件上传至天河机之后，使用合适的 MPI 编译器编译。\n\n```shell\nmpif90 <源程序.f90> -o <编译完成后的程序名>\n```\n\n例如：\n\n```shell\nmpif90 expmtt.f90 -o cyrain\n```\n\n### 8.3 实际操作\n\n「纸上得来终觉浅，绝知此事要躬行。」\n\n#### 8.3.1 例子\n\n对 8 * 8 的矩阵进行转置，使用四台机器。mat01.txt, mat02.txt, mat03.txt, mat04.txt 四块 4 * 4 的矩阵。下面是用于测试的源代码。\n\n```fortran\nprogram main\n    include 'mpif.h'\n    character *(3) fname\n    dimension mymat (4, 4), mytmat(4, 4), mymatr(4, 4)\n    integer mymat, mytmat, mymatr\n    integer ierr, myid, num, status(mpi_status_size)\n    call mpi_init(ierr)\n    call mpi_comm_rank(mpi_comm_world, myid, ierr)\n    call mpi_comm_size(mpi_comm_world, num, ierr)\n    fname = 'mat'\n    open(1, file = fname//char(48 + myid)//'1.txt', status = 'old')\n    open(2, file = fname//char(48 + myid)//'2.txt', status = 'new')\n\n    if (myid .eq. 0) then\n        write(2, *) 'The primary process'\n        write(2, *) 'myid =', myid\n        write(2, *) 'number of processors =', num\n    else\n        write(2, *) 'An assistance process'\n        write(2, *) 'myid =', myid\n        write(2, *) 'number of processors =', num\n    end if\n\n    do i = 1, 4\n        read(1, 100) (mymat(i, j), j = 1, 4)\n    end do\n    100 format(4i5)\n    call mpi_barrier(mpi_comm_world, ierr)\n    ! Wait for end of read data from file 1, part of the total 8*8 matrix\n    if ((myid .eq. 0) .or. (myid .eq. 3)) then\n        do i = 1, 4\n            do j = 1, 4\n                mytmat(i, j) = mymat(j, i)\n            end do\n        end do\n    else\n        if (myid .eq. 1) then\n            call mpi_send(mymat, 16, mpi_integer, 2, 0, mpi_comm_world, ierr)\n            call mpi_recv(mymatr, 16, mpi_integer, 2, 0, mpi_comm_world, status, ierr)\n        else\n            if (myid .eq. 2) then\n                call mpi_send(mymat, 16, mpi_integer, 1, 0, mpi_comm_world, ierr)\n                call mpi_recv(mymatr, 16, mpi_integer, 1, 0, mpi_comm_world, status, ierr)\n            end if\n        end if\n    end if\n    call mpi_barrier(mpi_comm_world, ierr)\n    if ((myid .eq. 1) .or. (myid .eq. 2)) then\n        do i = 1, 4\n            do j = 1, 4\n                mytmat(i, j) = mymatr(j, i)\n            end do\n        end do\n    end if\n    do i = 1, 4\n        write(2, 100) (mytmat(i, j), j = 1, 4)\n    end do\n    close(1)\n    close(2)\n    call mpi_finalize(ierr)\nend program main\n```\n\n#### 8.3.2 遇到问题\n\n以下是在登录天河计算机时的界面展示。\n\n```shell\n[stu05@ln1%tianhe ~]$ ls\nChenChangyu   les7         result4.log  results.log   results3.log  results6.log  ?????????  ?????????  ?????????  ??????\nNPB3.3.1      result1.log  result5.log  results1.log  results4.log  results7.log  ?????????  ??????     ?????????\nNPB3.3.1.tgz  result3.log  result6.log  results2.log  results5.log  ?????????     ?????????  ?????????  ??????\n[stu05@ln1%tianhe ~]$ cd ChenChangyu\n[stu05@ln1%tianhe ChenChangyu]$ ls\nMPI-Matrix  example\n[stu05@ln1%tianhe ChenChangyu]$ cd example\n[stu05@ln1%tianhe example]$ ls\nMAT01.TXT  MAT11.TXT  MAT21.TXT  MAT31.TXT  expmtt.f90\n[stu05@ln1%tianhe example]$ mpif90 expmtt.f90 -o /ChenChangyu/example/expmtt\nifort: internal error: error generating temporary file name, check disk space and permissions  (shared/driver/hostutil.c, line 853)\n[stu05@ln1%tianhe example]$\n```\n\n可以看到，编译失败啦！哈哈哈哈哈哈！一开始以为权限不够，于是尝试着更改权限。\n\n```shell\nchmod 777 /example\n```\n\n现在我的 `example` 文件夹下的所有文件的权限都是 `777`，可读可写可执行，但是问题仍然没有解决。注意，更改权限是很危险的行为，一般不建议使用。\n","tags":["开发与应用"]},{"title":"你好 2022","url":"/2022/01/01/2022-01-01-你好2022/","content":"\n# 你好 2022\n\n## 序言\n\n&emsp;&emsp;不知不觉中，一觉睡醒就到了 2022 年的一月了，是时候应该回顾一下、总结一下去年的所得所失了。全文较长，请安排好阅读时间，感谢你阅读完。\n\n&emsp;&emsp;当你看到这些文字的时候，应该已经是 1 月 1 日或者之后的时间了，但是没关系，对于我来说，重要的是我在这些文字里写了什么，我在 2021 年有什么收获可以和你分享，在 2021 年遇到了什么不愉快的事情可以和你吐槽；在 2021 年有什么教训值得自己吸取，有什么经验值得自己积累。\n\n&emsp;&emsp;亲爱的读者，为了你的身体和心理健康，我还是要友情提醒一句。 ***如果你在阅读这些文字的过程中，产生了任何心理上或身体上的不适，无论你阅读到什么位置，请立刻关闭本文，并寻找专业人士帮助。*** 虽然这不太可能发生，我也不希望有这种事发生，但是个人认为还是要有个说明。\n\n## 第一部分\n\n&emsp;&emsp;去年，也就是 2021 的上半年，我还是一个即将毕业的高中生。当我仍在高中的时候，我对我在高中所经历的一切、拥有的一切都习以为常。我以为高中生活无非就是如此，每天早上起床、去饭堂吃早餐：蛋挞、面包、甜甜圈、三明治、糖水……（此处省略 sizeof(早餐) 个字）然后去课室，自习、早读、上课、课间休息然后下课。然后等饭堂没那么多人的时候饭堂吃午餐：咖喱鸡……（此处省略 sizeof(午餐) 个字）睡过午觉之后，继续上下午的课。晚餐也是一样，每天都考虑一下要不要吃一个小火锅，要不要试试新出的金汤肥牛，又或者是白汁意面，还是卤蛋盖饭……（此处省略 sizeof(晚餐) 个字）\n\n&emsp;&emsp;日子就这么一天天过去了，然后高考了，接着我从高中毕业了。等到高考成绩公布的时候，很遗憾，这个分数是在是说高不算高，说低不算低。然后填志愿，由于之前没有参加某南某工大学的综合测评，所以别无选择，填了我现在的大学，被我现在在读的大学录取了，来到我现在所处的大学读书了。\n\n> 那些在没有了解过专业就盲目跟风填报热门专业的同学，提高了喜欢这些专业的同学的学习成本，是罪恶的，应当予以批评。\n> \n> ——沃·兹基·硕德\n\n&emsp;&emsp;在收到录取通知书之后，我就准备收拾东西，离开我生活了 18 年的广州，准备前往人称「网红城市」的长沙。第一部分也就到此结束了，但其实也没有完全结束。\n\n## 第二部分\n\n&emsp;&emsp;我来到了长沙，不到两天就深刻地感觉到了天壤之别。夸张点说，海鲜直接全部消失，取而代之的是满眼的「红色蔬菜」。我开始感觉到有些不适应，但一开始没有很明显。我对这边的饭菜的最初印象是很多油很多盐。用同学的话来说就是「好油腻啊」。说实话，我可以接受长沙的辣椒，但是有点不能接受每次吃完饭后都是满嘴的油，还要疯狂喝水。虽说现在油盐酱醋都不是什么价格昂贵的调料，但是少下点不仅可以节约食品的经费开支，而且对身体健康有好处，可以有效降低患……（此处省略 sizeof(相关疾病) 个字）的风险。\n\n&emsp;&emsp;在长沙逛了几天，总体感觉还是不错的，除了——垃圾桶。不是说不能有垃圾桶，只是我觉得目前来看好像垃圾桶的数量多的有些过了火。五步一桶，十步一车，廊腰缦回，檐牙高啄，啊不是。反正就是垃圾桶很多，给人一种到处都可以扔垃圾的错觉。另外，长沙地铁也是挺少人的，虽然我认为的「少人」在长沙同学的眼里可能是「拥挤」。天心区很繁华，好玩的东西很多，但是让我有一种不安全感。是错觉吗？我不知道。听说坑蒙拐骗比较多，有一点点体会。电动车是真的多，然后我是第一次知道修在人行道上与人行道同高的柏油绿道行人不能走，简直离谱。然后这边似乎非常喜欢把双行线硬生生地走成单行线。这里的防疫措施好像不是很到位，街上走动都没人带口罩，只能说是不够自觉。\n\n&emsp;&emsp;学校环境很优美，格局够开放，但是思维好像还有点保守（？也许，不确定）。我在这里遇到了非常多的非常不错的非常友善的非常优秀的同学们，学习的资源也挺丰富的，除去个别问题，感觉还是很好的。\n\n## 第三部分\n\n&emsp;&emsp;既然提到学校了，我也就顺带回顾一下 2021 年我在大学的经历。军训，一言难尽，撇开不谈。在 2021 年的后半年，我觉得可以说是有得有失。\n\n&emsp;&emsp;在 2021 年，我因为一分的差距和选修第二外语的资格失之交臂——分数线是 136，而我高考英语是 135。在这一个不管你是什么地区，考试形式是什么样都是统一标准的时代，就算我高考口语拿了 20 分满分又有什么用。一堆高考不练口语和听力的同学，靠着刷题蹭分，却连简单的英文提示都看不懂。用现在网络流行用语来说，就是「笑死，一群英语说的稀烂的人还能去选其他外语课程，少修几个学分😅」。虽然如此，在 2021 年的后半年还是有些让我比较开心的事情的。我的选修课选到了 Fortran 语言编程实践，虽然 Fortran 现在几乎不怎么被使用了，但是仍然活跃在科学计算领域。这门课的老师很好，我也有幸学习使用学校国家超算长沙中心的天河计算机。这可以说是我前所未有的体验。在学期过了大约四分之一的时候，碰巧 HNU 微软俱乐部招新。我在毫无准备的情况下去面试了 GUI，Python，Web 三个小组，结果三个小组的面试全部通过了。妙啊。这学期的期中考试，C++ 程序设计拿到了满分，这个也没什么好说的。在这学期的末尾，我如愿加入了舞蹈社 RA 舞团，下学期准备开启新的旅程。\n\n&emsp;&emsp;在 2021 年的 HNU 网页设计大赛，和舍友一起辛辛苦苦做的网页，因为上课，没有时间去答辩，于是——队友不懂怎么操作（计科的同学不应该是这个水平），耗尽了 3 分钟的答辩时间，从此无缘决赛。现在 2022 年了，我绝对不会再允许这种事情再次发生。\n\n&emsp;&emsp;最近的令人尴尬的事情发生在上个星期。HNU 的 ACM 大学生程序设计新生赛，我在毫无准备的情况下报名参赛了，紧接着在毫无准备的情况下去比赛了，随后在毫无准备的情况下看到了比赛结果。5 个小时的比赛下来，一共 12 道题，我只通过了 3 道题，拿了 3 个气球，结果还有二等奖……\n\n&emsp;&emsp;2022 年已经来了，以后再也不毫无准备就做事情了……实在是太尴尬了。\n\n## 结束，也是开始\n\n&emsp;&emsp;在上一年里，有欢笑，有悲伤，有汗水，有泪水。经历过因为中暑倒在 37 摄氏度的军训场上，也体会过帮助同学找回身份证后被感谢的喜悦；尝试过舞团的面试，也参加过编程的比赛。\n\n&emsp;&emsp;感谢这一年里陪伴我的所有人，感谢正在阅读本文的你，是你们的支持让我感觉不孤单；感谢我的高中，让我有一个值得怀念和记忆的高三生活；感谢我的 MacBook Pro，从来没有蓝屏死机过；感谢我的眼睛，让我感受到这大千世界里五彩斑斓的黑色和各种色号的红色；感谢我喜欢的人，没别的，就是想感谢。\n\n&emsp;&emsp;在本文的最后，也是 2022 的开始，愿世界疫情早日结束，愿中美关系早日回归正轨，愿中东局势早日稳定，愿少数群体的权益得到更好的保障。也希望自己努力在每一件事上做到最好。各位，2022 新年快乐！\n\n> 本文为 Rain Chen 原创，转载请注明出处：https://chen-rain.github.io\n> <br>All Rights Reserved.\n\n","tags":["杂谈碎笔"]},{"title":"让 Terminal 飞起来","url":"/2021/12/19/2021-12-19-让Terminal飞起来/","content":"\n# 让 Terminal 飞起来\n\n## 使用 iTerm\n\n### 安装\n\n从这里下载安装：[iTerm2](https://iterm2.com)\n\n把 iTerm.app 拖入 Applications 文件夹之后，就可以打开使用了。根据自己的需要对 iTerm 进行设置，例如终端上的显示信息等。\n\n### 配置\n\n我的 iTerm 配置文件，如下所示：\n\n```json\n{\n  \"Ansi 6 Color\" : {\n    \"Green Component\" : 0.73333334922790527,\n    \"Red Component\" : 0,\n    \"Blue Component\" : 0.73333334922790527\n  },\n  \"Tags\" : [\n\n  ],\n  \"Ansi 12 Color\" : {\n    \"Green Component\" : 0.3333333432674408,\n    \"Red Component\" : 0.3333333432674408,\n    \"Blue Component\" : 1\n  },\n  \"Ansi 7 Color\" : {\n    \"Green Component\" : 0.73333334922790527,\n    \"Red Component\" : 0.73333334922790527,\n    \"Blue Component\" : 0.73333334922790527\n  },\n  \"Ansi 8 Color\" : {\n    \"Green Component\" : 0.3333333432674408,\n    \"Red Component\" : 0.3333333432674408,\n    \"Blue Component\" : 0.3333333432674408\n  },\n  \"Bold Color\" : {\n    \"Green Component\" : 1,\n    \"Red Component\" : 1,\n    \"Blue Component\" : 1\n  },\n  \"Ansi 9 Color\" : {\n    \"Green Component\" : 0.3333333432674408,\n    \"Red Component\" : 1,\n    \"Blue Component\" : 0.3333333432674408\n  },\n  \"Ansi 3 Color\" : {\n    \"Green Component\" : 0.73333334922790527,\n    \"Red Component\" : 0.73333334922790527,\n    \"Blue Component\" : 0\n  },\n  \"Right Option Key Sends\" : 0,\n  \"Rows\" : 25,\n  \"Default Bookmark\" : \"No\",\n  \"Blend\" : 0.49971580615942024,\n  \"Cursor Guide Color\" : {\n    \"Red Component\" : 0.70214027166366577,\n    \"Color Space\" : \"sRGB\",\n    \"Blue Component\" : 1,\n    \"Alpha Component\" : 0.25,\n    \"Green Component\" : 0.92681378126144409\n  },\n  \"Non-ASCII Anti Aliased\" : true,\n  \"Use Bright Bold\" : true,\n  \"Ansi 10 Color\" : {\n    \"Green Component\" : 1,\n    \"Red Component\" : 0.3333333432674408,\n    \"Blue Component\" : 0.3333333432674408\n  },\n  \"Ambiguous Double Width\" : false,\n  \"Jobs to Ignore\" : [\n    \"rlogin\",\n    \"ssh\",\n    \"slogin\",\n    \"telnet\"\n  ],\n  \"Show Status Bar\" : true,\n  \"Ansi 15 Color\" : {\n    \"Green Component\" : 1,\n    \"Red Component\" : 1,\n    \"Blue Component\" : 1\n  },\n  \"Foreground Color\" : {\n    \"Green Component\" : 0.73333334922790527,\n    \"Red Component\" : 0.73333334922790527,\n    \"Blue Component\" : 0.73333334922790527\n  },\n  \"Working Directory\" : \"\\/Users\\/rainchen\",\n  \"Blinking Cursor\" : false,\n  \"Disable Window Resizing\" : true,\n  \"Sync Title\" : false,\n  \"Prompt Before Closing 2\" : false,\n  \"BM Growl\" : true,\n  \"Command\" : \"\",\n  \"Description\" : \"Default\",\n  \"Mouse Reporting\" : true,\n  \"Screen\" : -1,\n  \"Selection Color\" : {\n    \"Green Component\" : 0.8353000283241272,\n    \"Red Component\" : 0.70980000495910645,\n    \"Blue Component\" : 1\n  },\n  \"Initial Use Transparency\" : true,\n  \"Only The Default BG Color Uses Transparency\" : false,\n  \"Columns\" : 80,\n  \"Idle Code\" : 0,\n  \"Ansi 13 Color\" : {\n    \"Green Component\" : 0.3333333432674408,\n    \"Red Component\" : 1,\n    \"Blue Component\" : 1\n  },\n  \"Custom Command\" : \"No\",\n  \"ASCII Anti Aliased\" : true,\n  \"Non Ascii Font\" : \"Monaco 12\",\n  \"Vertical Spacing\" : 1,\n  \"Use Bold Font\" : true,\n  \"Option Key Sends\" : 0,\n  \"Selected Text Color\" : {\n    \"Green Component\" : 0,\n    \"Red Component\" : 0,\n    \"Blue Component\" : 0\n  },\n  \"Background Color\" : {\n    \"Green Component\" : 0,\n    \"Red Component\" : 0,\n    \"Blue Component\" : 0\n  },\n  \"Character Encoding\" : 4,\n  \"Ansi 11 Color\" : {\n    \"Green Component\" : 1,\n    \"Red Component\" : 1,\n    \"Blue Component\" : 0.3333333432674408\n  },\n  \"Use Italic Font\" : true,\n  \"Unlimited Scrollback\" : true,\n  \"Keyboard Map\" : {\n    \"0xf700-0x260000\" : {\n      \"Text\" : \"[1;6A\",\n      \"Action\" : 10\n    },\n    \"0x37-0x40000\" : {\n      \"Text\" : \"0x1f\",\n      \"Action\" : 11\n    },\n    \"0x32-0x40000\" : {\n      \"Text\" : \"0x00\",\n      \"Action\" : 11\n    },\n    \"0xf709-0x20000\" : {\n      \"Text\" : \"[17;2~\",\n      \"Action\" : 10\n    },\n    \"0xf70c-0x20000\" : {\n      \"Text\" : \"[20;2~\",\n      \"Action\" : 10\n    },\n    \"0xf729-0x20000\" : {\n      \"Text\" : \"[1;2H\",\n      \"Action\" : 10\n    },\n    \"0xf72b-0x40000\" : {\n      \"Text\" : \"[1;5F\",\n      \"Action\" : 10\n    },\n    \"0xf705-0x20000\" : {\n      \"Text\" : \"[1;2Q\",\n      \"Action\" : 10\n    },\n    \"0xf703-0x260000\" : {\n      \"Text\" : \"[1;6C\",\n      \"Action\" : 10\n    },\n    \"0xf700-0x220000\" : {\n      \"Text\" : \"[1;2A\",\n      \"Action\" : 10\n    },\n    \"0xf701-0x280000\" : {\n      \"Text\" : \"0x1b 0x1b 0x5b 0x42\",\n      \"Action\" : 11\n    },\n    \"0x38-0x40000\" : {\n      \"Text\" : \"0x7f\",\n      \"Action\" : 11\n    },\n    \"0x33-0x40000\" : {\n      \"Text\" : \"0x1b\",\n      \"Action\" : 11\n    },\n    \"0xf703-0x220000\" : {\n      \"Text\" : \"[1;2C\",\n      \"Action\" : 10\n    },\n    \"0xf701-0x240000\" : {\n      \"Text\" : \"[1;5B\",\n      \"Action\" : 10\n    },\n    \"0xf70d-0x20000\" : {\n      \"Text\" : \"[21;2~\",\n      \"Action\" : 10\n    },\n    \"0xf702-0x260000\" : {\n      \"Text\" : \"[1;6D\",\n      \"Action\" : 10\n    },\n    \"0xf729-0x40000\" : {\n      \"Text\" : \"[1;5H\",\n      \"Action\" : 10\n    },\n    \"0xf706-0x20000\" : {\n      \"Text\" : \"[1;2R\",\n      \"Action\" : 10\n    },\n    \"0x34-0x40000\" : {\n      \"Text\" : \"0x1c\",\n      \"Action\" : 11\n    },\n    \"0xf700-0x280000\" : {\n      \"Text\" : \"0x1b 0x1b 0x5b 0x41\",\n      \"Action\" : 11\n    },\n    \"0x2d-0x40000\" : {\n      \"Text\" : \"0x1f\",\n      \"Action\" : 11\n    },\n    \"0xf70e-0x20000\" : {\n      \"Text\" : \"[23;2~\",\n      \"Action\" : 10\n    },\n    \"0xf702-0x220000\" : {\n      \"Text\" : \"[1;2D\",\n      \"Action\" : 10\n    },\n    \"0xf703-0x280000\" : {\n      \"Text\" : \"0x1b 0x1b 0x5b 0x43\",\n      \"Action\" : 11\n    },\n    \"0xf700-0x240000\" : {\n      \"Text\" : \"[1;5A\",\n      \"Action\" : 10\n    },\n    \"0xf707-0x20000\" : {\n      \"Text\" : \"[1;2S\",\n      \"Action\" : 10\n    },\n    \"0xf70a-0x20000\" : {\n      \"Text\" : \"[18;2~\",\n      \"Action\" : 10\n    },\n    \"0x35-0x40000\" : {\n      \"Text\" : \"0x1d\",\n      \"Action\" : 11\n    },\n    \"0xf70f-0x20000\" : {\n      \"Text\" : \"[24;2~\",\n      \"Action\" : 10\n    },\n    \"0xf703-0x240000\" : {\n      \"Text\" : \"[1;5C\",\n      \"Action\" : 10\n    },\n    \"0xf701-0x260000\" : {\n      \"Text\" : \"[1;6B\",\n      \"Action\" : 10\n    },\n    \"0xf702-0x280000\" : {\n      \"Text\" : \"0x1b 0x1b 0x5b 0x44\",\n      \"Action\" : 11\n    },\n    \"0xf72b-0x20000\" : {\n      \"Text\" : \"[1;2F\",\n      \"Action\" : 10\n    },\n    \"0x36-0x40000\" : {\n      \"Text\" : \"0x1e\",\n      \"Action\" : 11\n    },\n    \"0xf708-0x20000\" : {\n      \"Text\" : \"[15;2~\",\n      \"Action\" : 10\n    },\n    \"0xf701-0x220000\" : {\n      \"Text\" : \"[1;2B\",\n      \"Action\" : 10\n    },\n    \"0xf70b-0x20000\" : {\n      \"Text\" : \"[19;2~\",\n      \"Action\" : 10\n    },\n    \"0xf702-0x240000\" : {\n      \"Text\" : \"[1;5D\",\n      \"Action\" : 10\n    },\n    \"0xf704-0x20000\" : {\n      \"Text\" : \"[1;2P\",\n      \"Action\" : 10\n    }\n  },\n  \"Window Type\" : 0,\n  \"Blur Radius\" : 64,\n  \"Background Image Location\" : \"\",\n  \"Blur\" : true,\n  \"Badge Color\" : {\n    \"Red Component\" : 1,\n    \"Color Space\" : \"sRGB\",\n    \"Blue Component\" : 0,\n    \"Alpha Component\" : 0.5,\n    \"Green Component\" : 0.14910027384757996\n  },\n  \"Scrollback Lines\" : 0,\n  \"Send Code When Idle\" : false,\n  \"Close Sessions On End\" : 0,\n  \"Terminal Type\" : \"xterm-256color\",\n  \"Visual Bell\" : true,\n  \"Flashing Bell\" : false,\n  \"Status Bar Layout\" : {\n    \"components\" : [\n      {\n        \"class\" : \"iTermStatusBarClockComponent\",\n        \"configuration\" : {\n          \"knobs\" : {\n            \"base: priority\" : 5,\n            \"base: compression resistance\" : 1,\n            \"shared text color\" : {\n              \"Red Component\" : 0.90000000000000002,\n              \"Color Space\" : \"sRGB\",\n              \"Blue Component\" : 0.63,\n              \"Alpha Component\" : 1,\n              \"Green Component\" : 0.63\n            },\n            \"format\" : \"M\\/dd h:mm\"\n          },\n          \"layout advanced configuration dictionary value\" : {\n            \"remove empty components\" : false,\n            \"font\" : \".AppleSystemUIFont 12\",\n            \"algorithm\" : 0,\n            \"auto-rainbow style\" : 3\n          }\n        }\n      },\n      {\n        \"class\" : \"iTermStatusBarWorkingDirectoryComponent\",\n        \"configuration\" : {\n          \"knobs\" : {\n            \"path\" : \"path\",\n            \"maxwidth\" : 1.7976931348623157e+308,\n            \"base: priority\" : 5,\n            \"shared text color\" : {\n              \"Red Component\" : 0.90000000000000002,\n              \"Color Space\" : \"sRGB\",\n              \"Blue Component\" : 0.63,\n              \"Alpha Component\" : 1,\n              \"Green Component\" : 0.84060000000000001\n            },\n            \"base: compression resistance\" : 1,\n            \"minwidth\" : 0\n          },\n          \"layout advanced configuration dictionary value\" : {\n            \"remove empty components\" : false,\n            \"font\" : \".AppleSystemUIFont 12\",\n            \"algorithm\" : 0,\n            \"auto-rainbow style\" : 3\n          }\n        }\n      },\n      {\n        \"class\" : \"iTermStatusBarJobComponent\",\n        \"configuration\" : {\n          \"knobs\" : {\n            \"base: compression resistance\" : 1,\n            \"base: priority\" : 5,\n            \"shared text color\" : {\n              \"Red Component\" : 0.74880000000000002,\n              \"Color Space\" : \"sRGB\",\n              \"Blue Component\" : 0.63,\n              \"Alpha Component\" : 1,\n              \"Green Component\" : 0.90000000000000002\n            },\n            \"minwidth\" : 0,\n            \"maxwidth\" : 1.7976931348623157e+308\n          },\n          \"layout advanced configuration dictionary value\" : {\n            \"remove empty components\" : false,\n            \"font\" : \".AppleSystemUIFont 12\",\n            \"algorithm\" : 0,\n            \"auto-rainbow style\" : 3\n          }\n        }\n      },\n      {\n        \"class\" : \"iTermStatusBarGitComponent\",\n        \"configuration\" : {\n          \"knobs\" : {\n            \"shared text color\" : {\n              \"Red Component\" : 0.63,\n              \"Color Space\" : \"sRGB\",\n              \"Blue Component\" : 0.7218,\n              \"Alpha Component\" : 1,\n              \"Green Component\" : 0.90000000000000002\n            },\n            \"iTermStatusBarGitComponentPollingIntervalKey\" : 2,\n            \"base: priority\" : 5,\n            \"minwidth\" : 0,\n            \"base: compression resistance\" : 1,\n            \"maxwidth\" : 1.7976931348623157e+308\n          },\n          \"layout advanced configuration dictionary value\" : {\n            \"remove empty components\" : false,\n            \"font\" : \".AppleSystemUIFont 12\",\n            \"algorithm\" : 0,\n            \"auto-rainbow style\" : 3\n          }\n        }\n      },\n      {\n        \"class\" : \"iTermStatusBarBatteryComponent\",\n        \"configuration\" : {\n          \"knobs\" : {\n            \"base: priority\" : 5,\n            \"shared text color\" : {\n              \"Red Component\" : 0.63,\n              \"Color Space\" : \"sRGB\",\n              \"Blue Component\" : 0.90000000000000002,\n              \"Alpha Component\" : 1,\n              \"Green Component\" : 0.86760000000000004\n            },\n            \"base: compression resistance\" : 1\n          },\n          \"layout advanced configuration dictionary value\" : {\n            \"remove empty components\" : false,\n            \"font\" : \".AppleSystemUIFont 12\",\n            \"algorithm\" : 0,\n            \"auto-rainbow style\" : 3\n          }\n        }\n      },\n      {\n        \"class\" : \"iTermStatusBarCPUUtilizationComponent\",\n        \"configuration\" : {\n          \"knobs\" : {\n            \"base: priority\" : 5,\n            \"shared text color\" : {\n              \"Red Component\" : 0.63,\n              \"Color Space\" : \"sRGB\",\n              \"Blue Component\" : 0.90000000000000002,\n              \"Alpha Component\" : 1,\n              \"Green Component\" : 0.65700000000000003\n            },\n            \"base: compression resistance\" : 1\n          },\n          \"layout advanced configuration dictionary value\" : {\n            \"remove empty components\" : false,\n            \"font\" : \".AppleSystemUIFont 12\",\n            \"algorithm\" : 0,\n            \"auto-rainbow style\" : 3\n          }\n        }\n      },\n      {\n        \"class\" : \"iTermStatusBarMemoryUtilizationComponent\",\n        \"configuration\" : {\n          \"knobs\" : {\n            \"base: priority\" : 5,\n            \"shared text color\" : {\n              \"Red Component\" : 0.81359999999999999,\n              \"Color Space\" : \"sRGB\",\n              \"Blue Component\" : 0.90000000000000002,\n              \"Alpha Component\" : 1,\n              \"Green Component\" : 0.63\n            },\n            \"base: compression resistance\" : 1\n          },\n          \"layout advanced configuration dictionary value\" : {\n            \"remove empty components\" : false,\n            \"font\" : \".AppleSystemUIFont 12\",\n            \"algorithm\" : 0,\n            \"auto-rainbow style\" : 3\n          }\n        }\n      },\n      {\n        \"class\" : \"iTermStatusBarNetworkUtilizationComponent\",\n        \"configuration\" : {\n          \"knobs\" : {\n            \"base: priority\" : 5,\n            \"shared text color\" : {\n              \"Red Component\" : 0.90000000000000002,\n              \"Color Space\" : \"sRGB\",\n              \"Blue Component\" : 0.77580000000000005,\n              \"Alpha Component\" : 1,\n              \"Green Component\" : 0.63\n            },\n            \"base: compression resistance\" : 1\n          },\n          \"layout advanced configuration dictionary value\" : {\n            \"remove empty components\" : false,\n            \"font\" : \".AppleSystemUIFont 12\",\n            \"algorithm\" : 0,\n            \"auto-rainbow style\" : 3\n          }\n        }\n      }\n    ],\n    \"advanced configuration\" : {\n      \"remove empty components\" : false,\n      \"font\" : \".AppleSystemUIFont 12\",\n      \"algorithm\" : 0,\n      \"auto-rainbow style\" : 3\n    }\n  },\n  \"Show Timestamps\" : 0,\n  \"Silence Bell\" : false,\n  \"Ansi 14 Color\" : {\n    \"Green Component\" : 1,\n    \"Red Component\" : 0.3333333432674408,\n    \"Blue Component\" : 1\n  },\n  \"Name\" : \"rainchen\",\n  \"Cursor Text Color\" : {\n    \"Green Component\" : 1,\n    \"Red Component\" : 1,\n    \"Blue Component\" : 1\n  },\n  \"Shortcut\" : \"\",\n  \"Cursor Color\" : {\n    \"Green Component\" : 0.73333334922790527,\n    \"Red Component\" : 0.73333334922790527,\n    \"Blue Component\" : 0.73333334922790527\n  },\n  \"Transparency\" : 0.49817320478723409,\n  \"Ansi 0 Color\" : {\n    \"Green Component\" : 0,\n    \"Red Component\" : 0,\n    \"Blue Component\" : 0\n  },\n  \"Horizontal Spacing\" : 1,\n  \"Custom Directory\" : \"No\",\n  \"Guid\" : \"720BA903-717A-4AE9-A428-9E97E288F31C\",\n  \"Ansi 5 Color\" : {\n    \"Green Component\" : 0,\n    \"Red Component\" : 0.73333334922790527,\n    \"Blue Component\" : 0.73333334922790527\n  },\n  \"Use Non-ASCII Font\" : false,\n  \"Ansi 1 Color\" : {\n    \"Green Component\" : 0,\n    \"Red Component\" : 0.73333334922790527,\n    \"Blue Component\" : 0\n  },\n  \"Normal Font\" : \"SFMono-Regular 18\",\n  \"Ansi 2 Color\" : {\n    \"Green Component\" : 0.73333334922790527,\n    \"Red Component\" : 0,\n    \"Blue Component\" : 0\n  },\n  \"Ansi 4 Color\" : {\n    \"Green Component\" : 0,\n    \"Red Component\" : 0,\n    \"Blue Component\" : 0.73333334922790527\n  },\n  \"Link Color\" : {\n    \"Red Component\" : 0,\n    \"Color Space\" : \"sRGB\",\n    \"Blue Component\" : 0.73422712087631226,\n    \"Alpha Component\" : 1,\n    \"Green Component\" : 0.35915297269821167\n  }\n}\n```\n\n以上的文件可以实现窗口的半透明模糊背景效果，字体使用的是 San Francisco Mono，字号为 18。\n\n## 使用 oh-my-zsh\n\n### 安装\n\n官方的网址：[oh-my-zsh](https://ohmyz.sh)\n\n安装方式非常简单，只需要输入以下命令：\n\n```shell\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\n但是鉴于「众所周知的原因」，官方给出的安装方法经常会遇到各种奇奇怪怪的问题。所以，我又找到了另一种有点「简单粗暴」的安装方式。当然，你还是要能够访问 GitHub 才行。从 oh-my-zsh 的仓库中 clone 整个仓库到本地，放在一个你认为合适的位置，找到其中的 `install.sh` 文件（目录在 `ohmyzsh/master/tools/install.sh`），在终端运行即可。保持网络连接。\n\n如何在终端运行这个 `install.sh` 脚本？看下面：\n\n```shell\ncd /ohmyzsh/master/tools\nsh install.sh\n```\n\n如果看到 oh-my-zsh 的 Code Banner 就算安装完成了。\n\n### 配置\n\n首次启动终端的时候，会在用户目录下生成一个 `.zshrc` 的文件。对，就是这个名字，不要以为它没有文件名只有扩展名。使用文本编辑器打开它，比如使用 Visual Studio Code，Sublime Text，Emacs，Vim 等等，都行。总而言之你需要打开它，然后发现以下内容。\n\n```shell\n# If you come from bash you might have to change your $PATH.\n# export PATH=$HOME/bin:/usr/local/bin:$PATH\n\n# Path to your oh-my-zsh installation.\nexport ZSH=\"/Users/rainchen/.oh-my-zsh\"\n\n# Set name of the theme to load --- if set to \"random\", it will\n# load a random theme each time oh-my-zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\nZSH_THEME=\"rainsmac\"\n\n# Set list of themes to pick from when loading at random\n# Setting this variable when ZSH_THEME=random will cause zsh to load\n# a theme from this variable instead of looking in $ZSH/themes/\n# If set to an empty array, this variable will have no effect.\n# ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" )\n\n# Uncomment the following line to use case-sensitive completion.\n# CASE_SENSITIVE=\"true\"\n\n# Uncomment the following line to use hyphen-insensitive completion.\n# Case-sensitive completion must be off. _ and - will be interchangeable.\n# HYPHEN_INSENSITIVE=\"true\"\n\n# Uncomment one of the following lines to change the auto-update behavior\n# zstyle ':omz:update' mode disabled  # disable automatic updates\n# zstyle ':omz:update' mode auto      # update automatically without asking\n# zstyle ':omz:update' mode reminder  # just remind me to update when it's time\n\n# Uncomment the following line to change how often to auto-update (in days).\n# zstyle ':omz:update' frequency 13\n\n# Uncomment the following line if pasting URLs and other text is messed up.\n# DISABLE_MAGIC_FUNCTIONS=\"true\"\n\n# Uncomment the following line to disable colors in ls.\n# DISABLE_LS_COLORS=\"true\"\n\n# Uncomment the following line to disable auto-setting terminal title.\n# DISABLE_AUTO_TITLE=\"true\"\n\n# Uncomment the following line to enable command auto-correction.\n# ENABLE_CORRECTION=\"true\"\n\n# Uncomment the following line to display red dots whilst waiting for completion.\n# You can also set it to another string to have that shown instead of the default red dots.\n# e.g. COMPLETION_WAITING_DOTS=\"%F{yellow}waiting...%f\"\n# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)\n# COMPLETION_WAITING_DOTS=\"true\"\n\n# Uncomment the following line if you want to disable marking untracked files\n# under VCS as dirty. This makes repository status check for large repositories\n# much, much faster.\n# DISABLE_UNTRACKED_FILES_DIRTY=\"true\"\n\n# Uncomment the following line if you want to change the command execution time\n# stamp shown in the history command output.\n# You can set one of the optional three formats:\n# \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\"\n# or set a custom format using the strftime function format specifications,\n# see 'man strftime' for details.\n# HIST_STAMPS=\"mm/dd/yyyy\"\n\n# Would you like to use another custom folder than $ZSH/custom?\n# ZSH_CUSTOM=/path/to/new-custom-folder\n\n# Which plugins would you like to load?\n# Standard plugins can be found in $ZSH/plugins/\n# Custom plugins may be added to $ZSH_CUSTOM/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git)\n\nsource $ZSH/oh-my-zsh.sh\n\n# User configuration\n\n# export MANPATH=\"/usr/local/man:$MANPATH\"\n\n# You may need to manually set your language environment\n# export LANG=en_US.UTF-8\n\n# Preferred editor for local and remote sessions\n# if [[ -n $SSH_CONNECTION ]]; then\n#   export EDITOR='vim'\n# else\n#   export EDITOR='mvim'\n# fi\n\n# Compilation flags\n# export ARCHFLAGS=\"-arch x86_64\"\n\n# Set personal aliases, overriding those provided by oh-my-zsh libs,\n# plugins, and themes. Aliases can be placed here, though oh-my-zsh\n# users are encouraged to define aliases within the ZSH_CUSTOM folder.\n# For a full list of active aliases, run `alias`.\n#\n# Example aliases\n# alias zshconfig=\"mate ~/.zshrc\"\n# alias ohmyzsh=\"mate ~/.oh-my-zsh\"\n\nsource /opt/homebrew/Cellar/zsh-syntax-highlighting/0.7.1/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nsource /opt/homebrew/Cellar/zsh-autosuggestions/0.7.0/share/zsh-autosuggestions/zsh-autosuggestions.zsh\n\n```\n\n接下来你需要去编辑这个配置文件。设定自己喜欢的主题，这个主题可以是 oh-my-zsh 预设的主题，也可以自己做的主题。只要主题文件放在 oh-my-zsh 的安装位置的主题文件夹 `/Users/rainchen/.oh-my-zsh/themes` 下就行。\n\n```shell\nZSH_THEME=\"这里写你的主题名字\"\n```\n\n下面分享我的主题配置文件：（注意， Apple 的标记在某些系统上可能无法显示）\n\n```shell\nfunction toon {\n  echo -n \"\"\n}\n\nget_git_dirty() {\n  git diff --quiet || echo '*'\n}\n\nautoload -Uz vcs_info\nzstyle ':vcs_info:*' check-for-changes true\nzstyle ':vcs_info:*' unstagedstr '%F{red}*'   # display this when there are unstaged changes\nzstyle ':vcs_info:*' stagedstr '%F{yellow}+'  # display this when there are staged changes\nzstyle ':vcs_info:*' actionformats \\\n    '%F{5}%F{5}[%F{2}%b%F{3}|%F{1}%a%c%u%F{5}]%f '\nzstyle ':vcs_info:*' formats       \\\n    '%F{5}%F{5}[%F{2}%b%c%u%F{5}]%f '\nzstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'\nzstyle ':vcs_info:*' enable git cvs svn\n\ntheme_precmd () {\n    vcs_info\n}\n\nsetopt prompt_subst\nPROMPT='%{$fg[magenta]%}$(toon)%{$reset_color%} %~/ %# %{$reset_color%}${vcs_info_msg_0_}%{$reset_color%}'\n\nautoload -U add-zsh-hook\nadd-zsh-hook precmd theme_precmd\n\n```\n\n### 添加插件\n\n下面介绍我使用的两个比较好用而且经典的插件\n\n#### zsh-syntax-highlighting\n\n顾名思义，语法高亮。使用 Homebrew 安装。\n\n```shell\nbrew install zsh-syntax-highlighting\n```\n\n安装完之后，查看软件包的路径。然后把路径添加到 `.zshrc` 配置文件的最后。\n\n```shell\nsource /opt/homebrew/Cellar/zsh-syntax-highlighting/0.7.1/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\n```\n\n保存即可。随后在终端 Shell 中输入下面的指令来使配置生效。\n\n```shell\nsource ~/.zshrc\n```\n\n#### zsh-autosuggestions\n\n这个包，顾名思义，自动建议和补全。可以自动补全指令，减少了大量的输入，降低了出错的风险。\n\n同样，我们使用 Homebrew 安装这个软件包。\n\n```shell\nbrew install zsh-autosuggestions\n```\n\n安装完成之后，查看软件包的路径。然后把路径添加到 `.zshrc` 配置文件的最后。\n\n```shell\nsource /opt/homebrew/Cellar/zsh-autosuggestions/0.7.0/share/zsh-autosuggestions/zsh-autosuggestions.zsh\n```\n\n保存即可。随后在终端 Shell 中输入下面的指令来使配置生效。\n\n```shell\nsource ~/.zshrc\n```\n\n## 写在后面\n\n至此，我们的终端配置就基本完成了，之后可以根据自己的需要对终端进行配置。\n\n\n","tags":["Mac","开发与应用"]},{"title":"macOS 上的 Visual Studio Code 配置","url":"/2021/12/17/2021-12-17-macOS上的VSCode配置/","content":"\n# macOS 上的 Visual Studio Code 配置\n\n## C/C++ 编译调试配置\n\n### settings.json 文件配置\n\n- 需要安装`Code Runner`扩展。\n\n```json\n{\n    \"code-runner.runInTerminal\": true\n}\n```\n\n作用：在 VS Code 的集成终端里运行程序，可以输入与输出。\n\n### launch.json 文件配置\n\n- 需要安装`C/C++`扩展\n- 需要安装`CodeLLDB`扩展\n- 需要安装`C/C++ Clang Command Adapter`扩展\n\n```json\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"name\": \"C/C++: Debug\",\n            \"program\": \"${fileDirname}/${fileBasenameNoExtension}\",\n            \"args\": [],\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n```\n\n在原来的配置文件的基础上修改为以上内容。其中`\"program\": \"${fileDirname}/${fileBasenameNoExtension}\"`是说明生成二进制文件的位置。`\"cwd\"`一栏填工作文件夹`\"${workspaceFolder}\"`即可。\n\n### tasks.json 文件配置\n\n```json\n{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"C/C++: clang++ build active file\",\n            \"command\": \"/usr/bin/clang++\",\n            \"args\": [\n                \"-std=c++17\",\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}\"\n            ],\n            \"options\": {\n                \"cwd\": \"${fileDirname}\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"detail\": \"Task generated by Debugger.\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}\n\n```\n\n其中的`\"args\": []`里的是编译指令，根据你所使用的编译器来写，例如我的`\"command\": \"usr/bin/clang++\"`的编译指令就写在`\"args\": []`里面了。\n\n## Python 编译调试配置\n\n### settings.json 文件配置\n\n- 需要安装`Python`扩展\n- 需要安装一个版本的`Python`\n\n```json\n{\n    \"code-runner.runInTerminal\": true,\n    \"python.pythonPath\": \"/usr/local/bin/python3\"\n}\n```\n\n要在`settings.json`文件中添加`Python`解释器的路径。\n\n### launch.json 文件配置\n\n```json\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Python: Current File\",\n            \"type\": \"python\",\n            \"request\": \"launch\",\n            \"program\": \"${file}\",\n            \"console\": \"integratedTerminal\"\n        }\n    ]\n}\n```\n\n默认设置即可。\n\n### tasks.json 文件配置\n\n可以暂时不用。\n\n## Fortran 编译调试配置\n\n- 需要安装`gfortran`编译器\n- 需要安装`Modern Fortran`扩展\n- 需要安装`Fortran Breakpoint Support`扩展\n\n### settings.json 文件配置\n\n```json\n{\n    \"code-runner.runInTerminal\": true,\n    \"fortran.includePaths\": [\n        \"/usr/local/include\",\n        \"/usr/local\",\n        \"/usr/local/bin\"\n    ],\n    \"fortran.symbols\": [ \"function\", \"subroutine\"]\n}\n```\n\n要在此文件中写上`fortran`编译器的目录，比如我的目录`usr/local/bin`。\n\n### launch.json 文件配置\n\n```json\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n    {\n        \"type\": \"lldb\",\n        \"request\": \"launch\",\n        \"name\": \"Fortran: Debug\",\n        \"program\": \"${fileDirname}/${fileBasenameNoExtension}\",\n        \"args\": [],\n        \"cwd\": \"${workspaceFolder}\"\n    }\n    ]\n}\n```\n\n这里是有关程序运行的设定。\n\n### tasks.json 文件配置\n\n```json\n{\n    \"tasks\": [\n        {\n            \"type\": \"shell\",\n            \"label\": \"Fortran: gfortran\",\n            \"command\": \"gfortran\",\n            \"args\": [\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}\"\n            ],\n            \"options\": {\n                \"cwd\": \"${fileDirname}\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"detail\": \"Task generated by Debugger.\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}\n\n```\n\n这个文件是用来配置编译任务的，注意`\"type\"`、`\"label\"`以及`\"command\"`这几项需要自己写。\n\n## 结尾\n\n本文由 Rain Chen 自己摸索而成，仅供参考，不足之处，还请指出。\n\n> 转载请注明来源：https://chen-rain.github.io\n","tags":["Mac","开发与应用"]},{"title":"公众号用户使用守则","url":"/2021/11/28/2021-11-28-公众号用户使用守则/","content":"\n# 公众号用户使用守则\n\n## 重要说明\n\n在使用公众号之前请仔细阅读守则，并确保您不会违反其中的任何一条。如果您违反了任何一条，请自行承担后果。下面是守则的详细规定：\n\n## 规定细则\n\n### 第一条\n\n在任何时候使用公众号的时候，都应该遵守上一条规则以及本条规则以下的所有规则，否则我们无法保证您的安全，您必须自己承担后果。\n\n### 第二条\n\n如果您在使用公众号的途中，遇到弹出来的您认为奇怪的广告，请直接忽略，并假装没有看见它。切记不要长时间关注此类广告，尤其不应该用眼睛直接盯着看，更不要用手指点击它。否则我们将无法保证您的身心健康安全和财产安全。\n\n### 第三条\n\n不要试图探究这份守则为什么会出现在这里，以及不要试图弄清楚第一条规则的上一条规则是什么。如果有其他用户问起您有关第一条规则的上一条规则的问题，请直接回答「太可怕了」即可。如果对方执意追问，请直接离开，不要理会。\n\n### 第五条\n\n当您发表或者回复别人的评论的时候，如果您发现其他用户的评论后面加了「狗头」，请您也加上狗头。这是为了您的生命财产安全考虑，请不要违反，否则我们将无能为力。\n\n### 第六条\n\n有些用户，甚至我们的部分员工认为本守则的第四条有些不合理。请您无需理会，并假装没看见。\n\n### 第七条\n\n如果您看见或者听见有其他用户向您讲述第四条规定的内容，请立刻打断其讲述并转身离开，无需理会其他用户的反应。如果您已经知道了第四条规定的内容，请务必按照第一条规定的上一条规定所说去做，否则我们将无法帮助您。\n\n### 第八条\n\n如果您能够遵守以上所有的规定，我们将能够保证您安全使用公众号；否则，造成的一切严重后果都将有您自行承担。\n\n## 最后\n\n祝您拥有一个愉快的公众号使用体验，祝您拥有愉快的一天！\n\n> 本守则纯属笔者虚构，如有雷同，纯属见鬼。\n> 转载请注明出处：https://chen-rain.github.io\n","tags":["杂谈碎笔"]},{"title":"在基于 Apple Silicon 的 Mac 上配置 C++ 运行环境","url":"/2021/09/27/2021-09-27-基于Apple Silicon的Mac配置C++运行环境/","content":"\n# 在基于 Apple Silicon 的 Mac 上使用 Visual Studio Code 简单搭建 C++ 开发环境<br>Building C++ dev environment with Visual Studio simply on Mac based on Apple Silicon\n\n### 打开 Visual Studio Code，安装以下扩展<br>Open Visual Studio Code and install the following extensions\n\n- C/C++\n- C/C++ Clang Command Adapter\n- Code Runner\n- CodeLLDB\n\n### 在 Visual Studio Code 中打开一个你认为合适的文件夹<br>Open a suitabale folder in Visual Studio Code\n<br>\n打开 Settings，点按 Workspace 选项卡，搜索「RunInTerminal」,勾选为 True。<br>Open Settings, click Workspace item, search \"RunInTerminal\", turn it on.<br>\n<br>\n新建或打开一个文件，命名为「helloworld.cpp」，输入以下内容。<br>\nNew or open a file, name as \"helloworld.cpp\", type the following code in it.\n\n```cpp\n// helloworld.cpp -- the first\n#include <iostream>\nint main()\n{\n    using namespace std;\n    cout << \"Hello world!\";\n    return 0;\n}\n```\n\n点按右上角的绿色箭头运行。<br>Click the green arrow to run.<br>\n\n### 在该文件夹中的隐藏文件如「settings.json」等，可以根据自己的需要进行修改和配置<br>The hidden files can be change and config when you need to, for example, the \"settings.json\" file\n\n按下 ⌘Command+⇧Shift+. 来显示或不显示隐藏的文件和文件夹。<br>Press ⌘Command+⇧Shift+. to show or hide the hidden files or folders.<br><br>\n\n## 在基于Apple Silicon的Mac上使用Visual Studio Code进行C++程序调试<br>Debug C++ program with Visual Studio simply on Mac based on Apple Silicon\n\n### 你需要在 Visual Studio Code 中安装以下扩展<br>You need to install the following extensions\n\n- C/C++\n- CodeLLDB\n\n### 在 Visual Studio Code 中打开你的工作文件夹<br>Open your workfolder in Visual Studio Code\n\n打开一个实例，比如「helloworld.cpp」，然后按 F1 键，选择「C/C++: Build and Debug Active File」<br>Open an example, such as \"helloworld.cpp\", then press F1, select \"C/C++: Build and Debug Active File\"\n<br>\n<br>\nVisual Studio Code 将会自动生成「tasks.json」的文件，内容如下<br>\nVisual Studio Code will create \"tasks.json\" file automatically as follow<br>\n\n```json\n{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"C/C++: clang++ build active file\",\n            \"command\": \"/usr/bin/clang++\",\n            \"args\": [\n                \"-std=c++17\",\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}\"\n            ],\n            \"options\": {\n                \"cwd\": \"${fileDirname}\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"detail\": \"Task generated by Debugger.\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}\n```\n\n### 选择左侧菜单栏的「调试」图标，点击「Create a launch.json fiile」<br>Choose \"Debug\" icon, click \"Create a launch.json file\"\n\n选择「LLDB」选项，创建一个「launch.json」文件<br>Select \"LLDB\" option to create a \"launch.json\" file\n\n```json\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"name\": \"Debug\",\n            \"program\": \"${workspaceFolder}/<your program>\",\n            \"args\": [],\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n```\n<br>\n把以上内容改为以下内容<br>Change the above to below\n\n```json\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"name\": \"Debug\",\n            \"program\": \"${fileDirname}/${fileBasenameNoExtension}\",\n            \"args\": [],\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n```\n\n### 最后，按 ⌘Command + ⇧Shift + B 编译<br>Finally, press ⌘Command + ⇧Shift + B to compile\n\n按触控栏上的调试小箭头或 F5 进行调试<br>\nPress the arrow on the Touchbar or F5 to debug<br>\n<br><br>\n\n> ⚠️注意：这个笔记是根据网络上的各种资料和文档进行总结归纳的，仅供参考<br>⚠️Attention: This note is a summary according to some pages and files on the Internet\n","tags":["Mac","开发与应用"]},{"title":"花里胡哨！Code::Blocks 的美化教程来啦","url":"/2021/09/25/2021-09-25-Code::Blocks的美化教程/","content":"\n# Code::Blocks IDE 花里胡哨的美化教程\n\n## 前言：审美疲劳会降低效率\n\n为什么要做这个事情？（有同学想让我出一期更改字体和背景的教程（不是）。）为什么要让 Code::Blocks 变得美观？笔者个人认为，美观的界面能够让使用者提高效率，降低不必要的思维损耗去思考数字1和字母l的区别；除此之外，还可以让使用者赏心悦目，让代码的可读性提高。总而言之，本文将要介绍的美化教程不仅仅是字面意思的美化，还是为大家将来的 Coding 学习与生活提供方便。\n\n## 准备：你需要有什么东西\n\n为了做好在 Windows 平台上 Code::Blocks 的美化，你需要准备这些东西：\n\n- 你想要使用的字体\n- 一个安装有 Code::Blocks 的 Windows 系统的电脑\n- 脑子和手\n- 没有了\n\n## 一些说明：很重要，会影响使用体验\n\n### 关于字体\n\n不论你选择什么样的字体，都应该是「等宽（Mono）」的字体。敲黑板，这个要考，等宽字体，等宽字体，等宽字体！不然写出来的代码会很难看。另外一个要注意的点就是选择的字体应该易于区分。（把中文引号和英文引号搞混可不是什么好玩的事情）然后有一些程序员推荐字体，笔者就列在下面：\n\n- Menlo: 来自 Apple macOS 操作系统的默认等宽字体\n- Monaco: 来自 Apple macOS 操作系统的默认等宽字体\n- Ubuntu Mono: Ubuntu Linux 操作系统终端的默认等宽字体\n- Sarasa Mono: 中文名「更纱黑体」,由华人设计的支持中日韩文的编程字体\n- Consolas: 由 Lucas de Groot 设计的等宽字体\n\n### 关于背景\n\n容易凸显背景上的文本就行。\n\n## 开始动手\n\n### 配置主题\n\n打开 Code::Blocks，点击 `Settings` -> `Editor` -> `Syntax Highlighting`。然后请把视线移到右边，找到 `Colour Theme` 选择你喜欢的主题。点击下方的 `Background` 可以自定义背景颜色。\n\n### 配置字体\n\n打开 Code::Blocks，点击 `Settings` -> `Editor` -> `Font` -> `Choose`，选择你喜欢的字体和字号。推荐的字号是18，不至于太小导致看代码看到眼瞎。\n\n### 配置光标\n\n打开 Code::Blocks，点击 `Settings` -> `Editor` -> `Margins and caret` -> `Caret`，选择合适的光标大小和颜色。\n\n### 配置左侧行号区域\n\n打开 Code::Blocks，点击 `Settings` -> `Environment` -> `Colours`。找到以下内容。\n\n`Editor: Line numbers background colour`：修改行号的背景，选择喜欢的颜色添加即可。\n\n`Editor: Line numbers foreground colour`：修改行号的前景，选择喜欢的颜色添加即可。\n\n`Editor: Margin chrome colour`：修改行号与代码之间区域的颜色，选择喜欢的颜色添加即可。\n\n`Editor: Margin chrome highlight colour`：选择行号与代码之间区域的高亮颜色，选择喜欢的颜色添加即可。\n\n## 结束\n\n到此，我们的美化教程就告一段落啦。祝各位食用愉快！\n\n> 以上内容为笔者总结，参考了互联网上的资料，仅供参考。<br>\n> 转载请注明出处：<https://chen-rain.github.io>","tags":["开发与应用"]},{"title":"C/C++ \"expected an expression\"报错解决方案","url":"/2021/07/31/2021-07-31-C++标准问题解决方案/","content":"\n# C/C++ \"expected an expression\" 报错解决方案\n\n## 问题信息\n\n在 Visual Studio Code下 编写 C++ 程序。其中一道习题，程序设计如下。\n\n```cpp\n// 3_7_3.cpp\n#include <iostream>\nint main()\n{\n    using namespace std;\n    float deg;\n    float min;\n    float sec;\n    cout << \"Enter a latitude in degrees, minutes, and seconds: \\n\";\n    cout << \"First, enter the degrees: \";\n    cin >> deg;\n    cout << \"Next, enter the minutes of arc: \";\n    cin >> min;\n    cout << \"Finally, enter the seconds of arc: \";\n    cin >> sec;\n    float DEG;\n    DEG = deg + min / 60 + sec / 3600;\n    cout << deg << \" degrees, \" << min << \" minutes, \" << sec << \" seconds = \"\n    << DEG << \" degrees.\";\n    return 0;\n}\n```\n\n写完之后，在 `cout << deg << \"degrees, \"...` 之前出现了红色波浪线，点击运行，程序可以正常运行，可以输出正确结果。但是提示有一个问题：\n\n```\nexpected an expression C/C++ (29) [19,1]\n```\n\n## 问题原因\n\n该程序使用了 C++11 的标准，而 Visual Studio Code 默认使用 C++98 标准，导致报错但可以正常运行。\n\n## 解决方案\n\n打开工作文件夹下的隐藏 `.vscode` 文件夹，打开其中的 `tasks.json` 文件。内容如下。\n\n```json\n{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"C/C++: clang++ build active file\",\n            \"command\": \"/usr/bin/clang++\",\n            \"args\": [\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}\"\n            ],\n            \"options\": {\n                \"cwd\": \"${fileDirname}\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"detail\": \"Task generated by Debugger.\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}\n```\n\n在 `\"args\"` 后中括号中加上一条 `\"-std=c++11\"` 并保存，注意 json 语法中的逗号位置。修改后内容如下。\n\n```json\n{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"C/C++: clang++ build active file\",\n            \"command\": \"/usr/bin/clang++\",\n            \"args\": [\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}\",\n                \"-std=c++11\"\n            ],\n            \"options\": {\n                \"cwd\": \"${fileDirname}\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"detail\": \"Task generated by Debugger.\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}\n```\n\n回到 `.cpp` 源文件，错误提示消失了，程序可以正常编译运行。","tags":["Mac","开发与应用"]},{"title":"iPhone 中国大陆地区「科学上网」方式","url":"/2021/07/31/2021-07-31-iPhone中国大陆地区科学上网方式/","content":"\n# iPhone 中国大陆地区「科学上网」方式\n\n## 下载 Shadowrocket 的 `.ipa` 包（iOS Package Archive）\n\n传送门：<https://github.com/flyzy2005/ss-ssr-clients/raw/master/ios/Shadowrocket.ipa><br>\n文件位于 GitHub 站点上，不同地区访问及下载速度可能不尽相同。\n\n<!--\n## 下载并安装爱思助手\n\n传送门：<https://www.i4.cn><br>\nMac、Windows 和 Linux 版本都有，根据自己的操作系统选择。\n\n## 使用爱思助手把 `.ipa` 包载入 iPhone\n\n连接 iPhone，让 `.ipa` 文件使用爱思助手运行，即可安装。软件官方网站也有详细的教程。\n-->\n\n## 通过某些方法把 `.ipa` 包侧载入 iPhone 中\n\n> ❗️❗️❗️❗️警告：由于爱思助手劣迹斑斑，所以不再推荐使用。\n\n## 打开 Shadowrocket\n\n如果你使用 Clash，你应该知道怎么做。把自己使用的机场的 Shadowrocket 的 URL 复制进软件中，配置完成，打开全局代理。<br>\n如果你没有用过 Clash 之类的代理软件，你应该先去找一个机场，注册并订阅一个节点，然后在配置页找到复制 URL 按钮，复制链接进软件中。Clash 与 Shadowrocket 的操作方式相同。","tags":["Mac","开发与应用"]}]